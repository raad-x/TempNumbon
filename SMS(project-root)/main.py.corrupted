"""
Ring4 US-Only SMS Verification Bot - WITH PAYMENT WORKFLOW
Production-ready Telegram bot with payment approval system.
"""

import os
import sys
import logging
import asyncio
import re
import traceback
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Union

from telegram.ext import (
    Application, CommandHandler, CallbackQueryHandler,
    ContextTypes, MessageHandler, filters
)
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from tinydb import TinyDB, Query
from dotenv import load_dotenv

sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'src'))

# Import configuration manager
try:
    from src.config import Config, ConfigurationManager
    logger = logging.getLogger(__name__)
    logger.info("‚úÖ Configuration system loaded successfully")
except ImportError as config_error:
    print(f"‚ùå Failed to load configuration system: {config_error}")
    sys.exit(1)

SMSPoolAPI = None
WalletSystem = None
WALLET_SYSTEM_AVAILABLE = False

# Try to import wallet system and API modules
try:
    # Primary import strategy: from src package
    from src.smspool_api import SMSPoolAPI
    from src.wallet_system import WalletSystem
    WALLET_SYSTEM_AVAILABLE = True
    print("‚úÖ Wallet system and API modules loaded from src package")
except ImportError as src_error:
    try:
        # Fallback strategy: direct imports
        from src.smspool_api import SMSPoolAPI
        from src.wallet_system import WalletSystem
        WALLET_SYSTEM_AVAILABLE = True
        print("‚úÖ Wallet system and API modules loaded directly")
    except ImportError as direct_error:
        try:
            # Fallback strategy 2: absolute imports with current directory
            sys.path.insert(0, os.path.dirname(__file__))
            from src.smspool_api import SMSPoolAPI
            from src.wallet_system import WalletSystem
            WALLET_SYSTEM_AVAILABLE = True
            print("‚úÖ Wallet system and API modules loaded with absolute path")
        except ImportError as abs_error:
            # Final fallback: create minimal mock classes to prevent crashes
            WALLET_SYSTEM_AVAILABLE = False
            print("‚ö†Ô∏è Wallet system modules not found:")
            print(f"   - src package error: {src_error}")
            print(f"   - direct import error: {direct_error}")
            print(f"   - absolute path error: {abs_error}")
            print("‚ö†Ô∏è Running with limited functionality - mock classes will be used")
            print(f"   - direct import error: {direct_error}")
            print(f"   - absolute path error: {abs_error}")
            print("üìù Running in limited mode - wallet functionality disabled")

            # Create minimal fallback classes to prevent AttributeError
            class MockWalletSystem:
                def __init__(self, database):
                    self.db = database
                    self.MIN_DEPOSIT_USD = 5.00
                    self.MAX_DEPOSIT_USD = 1000.00
                    # Add mock table attributes
                    self.deposits_table = None

                def get_user_balance(self, user_id):
                    """Mock implementation - always returns 0.00"""
                    _ = user_id  # Acknowledge unused parameter
                    return 0.00

                def has_sufficient_balance(self, user_id, amount):
                    """Mock implementation - always returns False"""
                    _ = user_id, amount  # Acknowledge unused parameters
                    return False

                def deduct_balance(self, user_id, amount, description, order_id=None):
                    """Mock implementation - always returns False"""
                    _ = user_id, amount, description, order_id  # Acknowledge unused parameters
                    return False

                def add_balance(self, user_id, amount, description, transaction_type='deposit'):
                    """Mock implementation - always returns False"""
                    _ = user_id, amount, description, transaction_type  # Acknowledge unused parameters
                    return False

                def process_service_purchase(self, user_id, service_price, service_name, order_id):
                    """Mock implementation - always returns False"""
                    _ = user_id, service_price, service_name, order_id  # Acknowledge unused parameters
                    return False

                def process_refund(self, user_id, refund_amount, order_id, reason):
                    """Mock implementation - always returns False"""
                    _ = user_id, refund_amount, order_id, reason  # Acknowledge unused parameters
                    return False

                def get_wallet_summary(self, user_id):
                    """Mock implementation - returns empty summary"""
                    _ = user_id  # Acknowledge unused parameter
                    return {
                        'balance': 0.00,
                        'total_deposited': 0.00,
                        'total_spent': 0.00,
                        'total_refunded': 0.00,
                        'recent_transactions': []
                    }

                def create_deposit_request(self, user_id, amount, binance_wallet):
                    """Mock implementation - returns deposit request structure"""
                    return {
                        'deposit_id': f'DEP_{user_id}_{int(datetime.now().timestamp())}',
                        'amount': amount,
                        'instructions': [
                            "*üí∞ Wallet Deposit Request*",
                            f"*Amount:* ${amount:.2f}",
                            f"*Wallet:* `{binance_wallet}`",
                            "",
                            f"‚ö†Ô∏è *IMPORTANT:* Send exactly ${amount:.2f}",
                            f"Include your user ID: {user_id} in transaction memo"
                        ]
                    }

                def get_pending_deposits(self):
                    """Mock implementation - returns empty list"""
                    return []

                def approve_deposit(self, deposit_id, admin_id):
                    """Mock implementation - always returns False"""
                    _ = deposit_id, admin_id  # Acknowledge unused parameters
                    return False

                def get_deposit_status(self, deposit_id):
                    """Mock implementation - returns None"""
                    _ = deposit_id  # Acknowledge unused parameter
                    return None

                def get_transaction_history(self, user_id, limit=20):
                    """Mock implementation - returns empty list"""
                    _ = user_id, limit  # Acknowledge unused parameters
                    return []

            class MockSMSPoolAPI:
                def __init__(self, api_key):
                    self.api_key = api_key

                async def purchase_ring4_number(self, *args, **kwargs):
                    """Mock implementation - returns failure response"""
                    _ = args, kwargs  # Acknowledge unused parameters
                    return {'success': False, 'message': 'API not available'}

                async def get_order_status(self, *args, **kwargs):
                    """Mock implementation - returns failure response"""
                    _ = args, kwargs  # Acknowledge unused parameters
                    return {'success': False, 'message': 'API not available'}

                async def cancel_order(self, *args, **kwargs):
                    """Mock implementation - returns failure response"""
                    _ = args, kwargs  # Acknowledge unused parameters
                    return {'success': False, 'message': 'API not available'}

                async def check_service_availability(self, *args, **kwargs):
                    """Mock implementation - returns failure response"""
                    _ = args, kwargs  # Acknowledge unused parameters
                    return {'success': False, 'message': 'API not available'}

                async def get_service_pricing(self, *args, **kwargs):
                    """Mock implementation - returns failure response"""
                    _ = args, kwargs  # Acknowledge unused parameters
                    return {'success': False, 'message': 'API not available'}

                async def get_available_services_for_purchase(self, *args, **kwargs):
                    """Mock implementation - returns failure response"""
                    _ = args, kwargs  # Acknowledge unused parameters
                    return {'success': False, 'message': 'API not available'}

                async def purchase_specific_service(self, *args, **kwargs):
                    """Mock implementation - returns failure response"""
                    _ = args, kwargs  # Acknowledge unused parameters
                    return {'success': False, 'message': 'API not available'}

                async def purchase_sms_number(self, *args, **kwargs):
                    """Mock implementation - returns failure response"""
                    _ = args, kwargs  # Acknowledge unused parameters
                    return {'success': False, 'message': 'API not available'}

                async def check_balance(self, *args, **kwargs):
                    """Mock implementation - returns failure response"""
                    _ = args, kwargs  # Acknowledge unused parameters
                    return {'success': False, 'message': 'API not available'}

            # Assign mock classes
            WalletSystem = MockWalletSystem
            SMSPoolAPI = MockSMSPoolAPI

# Load environment variables (override existing ones)
load_dotenv(override=True)

# =============================================================================
# ENHANCED LOGGING CONFIGURATION FOR DEBUGGING
# =============================================================================

# Configure comprehensive logging for debugging
logging.basicConfig(
    level=logging.DEBUG,  # Capture all log levels
    format='%(asctime)s - %(name)s - %(levelname)s - %(funcName)s:%(lineno)d - %(message)s',
    handlers=[
        logging.FileHandler('logs/ring4_bot.log', encoding='utf-8'),
        logging.StreamHandler()  # Console output
    ]
)

# Create specialized loggers for different components
logger = logging.getLogger(__name__)
api_logger = logging.getLogger('API')
payment_logger = logging.getLogger('PAYMENT')
purchase_logger = logging.getLogger('PURCHASE')
user_logger = logging.getLogger('USER')
performance_logger = logging.getLogger('PERFORMANCE')

# Set log levels for detailed debugging
logging.getLogger('telegram').setLevel(logging.INFO)
logging.getLogger('httpx').setLevel(logging.WARNING)
logging.getLogger('aiohttp').setLevel(logging.WARNING)

# =============================================================================
# CONSTANTS & CONFIGURATION (Now using centralized config system)
# =============================================================================

# Initialize configuration manager
config_manager = ConfigurationManager()

# Get configuration values from centralized system
RING4_SERVICE_ID = config_manager.get('RING4_SERVICE_ID')
RING4_COUNTRY_ID = config_manager.get('DEFAULT_COUNTRY_ID')

# SMSPool API Configuration
SMSPOOL_BASE_URL = "https://api.smspool.net"
SMSPOOL_API_KEY = config_manager.get('SMSPOOL_API_KEY')
BOT_TOKEN = config_manager.get('BOT_TOKEN')

# Admin Configuration
ADMIN_IDS = config_manager.get_admin_ids()

# Optimized Polling Configuration (from centralized config)
POLL_INTERVAL = config_manager.get('POLL_INTERVAL')
POLL_TIMEOUT = config_manager.get('POLL_TIMEOUT')
ORDER_EXPIRES_IN = config_manager.get('ORDER_EXPIRES_IN')

# Adaptive polling intervals from config
POLLING_INTERVALS = config_manager.get_polling_intervals()

# Performance optimization constants
MAX_CONSECUTIVE_FAILURES = config_manager.get('MAX_CONSECUTIVE_FAILURES')
API_TIMEOUT_SECONDS = config_manager.get('API_TIMEOUT_SECONDS')
MAX_POLLING_INTERVAL = config_manager.get('MAX_POLLING_INTERVAL')

# Paths (configurable)
DATA_DIR = Path("data")
LOGS_DIR = Path("logs")
# Extract filename
DB_PATH = DATA_DIR / config_manager.get('DATABASE_PATH').split('/')[-1]

# Ensure directories exist
DATA_DIR.mkdir(exist_ok=True)
LOGS_DIR.mkdir(exist_ok=True)

# Business configuration
BINANCE_WALLET = config_manager.get('BINANCE_WALLET')

# Check if bot is in maintenance mode
if config_manager.is_maintenance_mode():
    logger.warning("üöß Bot is in maintenance mode")
    MAINTENANCE_MESSAGE = config_manager.get_maintenance_message()
else:
    MAINTENANCE_MESSAGE = None

logger.info("‚úÖ Configuration loaded from centralized system")
logger.info("üìä Services enabled: %d", len(
    config_manager.get_enabled_services()))
logger.info("üë• Admins configured: %d", len(config_manager.get_admin_ids()))

# =============================================================================
# LOGGING CONFIGURATION
# =============================================================================


def setup_logging():
    """Setup production-grade logging"""
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(funcName)s:%(lineno)d - %(message)s',
        handlers=[
            logging.FileHandler(LOGS_DIR / 'ring4_bot.log', encoding='utf-8'),
            logging.StreamHandler(sys.stdout)
        ]
    )

    # Reduce noise from external libraries
    logging.getLogger('httpx').setLevel(logging.WARNING)
    logging.getLogger('telegram').setLevel(logging.WARNING)
    logging.getLogger('aiohttp').setLevel(logging.WARNING)

    return logging.getLogger(__name__)


logger = setup_logging()

# =============================================================================
# DATABASE OPERATIONS
# =============================================================================


class Database:
    """TinyDB database manager for Ring4 bot"""

    def __init__(self):
        self.db = TinyDB(DB_PATH)
        self.orders = self.db.table('orders')
        self.refunds = self.db.table('refunds')
        logger.info("üìÑ Database initialized: %s", DB_PATH)

    def create_order(self, user_id: int, order_data: Dict) -> int:
        """Create a new order record"""
        order = {
            'user_id': user_id,
            'order_id': order_data.get('order_id'),
            'number': order_data.get('number'),
            'cost': order_data.get('cost'),
            'status': 'pending',
            'created_at': datetime.now().isoformat(),
            'expires_at': (datetime.now() + timedelta(seconds=ORDER_EXPIRES_IN)).isoformat(),
            'otp': None,
            'otp_received_at': None
        }
        doc_id = self.orders.insert(order)
        logger.info("üìù Order created: %s for user %s",
                    order['order_id'], user_id)
        return doc_id

    def update_order_status(self, order_id: Union[int, str], status: str, otp: Optional[str] = None):
        """Update order status and OTP if provided"""
        Order = Query()
        update_data = {'status': status}
        if otp:
            update_data['otp'] = otp
            update_data['otp_received_at'] = datetime.now().isoformat()

        self.orders.update(update_data, Order.order_id == order_id)
        logger.info("üîÑ Order %s status updated to: %s", order_id, status)

    def get_order(self, order_id: Union[int, str]) -> Optional[Dict]:
        """Get order by ID"""
        Order = Query()
        result = self.orders.search(Order.order_id == order_id)
        return result[0] if result else None

    def get_user_orders(self, user_id: int, status: Optional[str] = None) -> List[Dict]:
        """Get orders for a user, optionally filtered by status"""
        Order = Query()
        if status:
            return [dict(doc) for doc in self.orders.search((Order.user_id == user_id) & (Order.status == status))]
        return [dict(doc) for doc in self.orders.search(Order.user_id == user_id)]

    def create_refund_request(self, user_id: int, order_id: Union[int, str]) -> int:
        """Create a refund request"""
        refund = {
            'user_id': user_id,
            'order_id': order_id,
            'status': 'pending',
            'requested_at': datetime.now().isoformat(),
            'processed_at': None,
            'processed_by': None
        }
        doc_id = self.refunds.insert(refund)
        logger.info("üí∞ Refund request created for order %s", order_id)
        return doc_id

    def get_pending_refunds(self) -> List[Dict]:
        """Get all pending refund requests"""
        Refund = Query()
        return [dict(doc) for doc in self.refunds.search(Refund.status == 'pending')]

    def update_refund_status(self, order_id: Union[int, str], status: str, admin_id: Optional[int] = None):
        """Update refund request status"""
        Refund = Query()
        update_data = {
            'status': status,
            'processed_at': datetime.now().isoformat()
        }
        if admin_id:
            update_data['processed_by'] = str(admin_id)

        self.refunds.update(update_data, Refund.order_id == order_id)
        logger.info("üí∞ Refund for order %s status updated to: %s",
                    order_id, status)

    def close(self):
        """Safely close database connections"""
        try:
            if hasattr(self, 'db') and self.db:
                self.db.close()
                logger.debug("üóÑÔ∏è Database connection closed")
        except OSError as e:
            logger.error("‚ùå Error closing database: %s", e)


# Global database instance
db = Database()

# Initialize wallet system
wallet_system = None
if WALLET_SYSTEM_AVAILABLE:
    try:
        wallet_system = WalletSystem(db)
        logger.info("‚úÖ Wallet system initialized successfully")
    except (ImportError, AttributeError, RuntimeError) as e:
        logger.error("‚ùå Failed to initialize wallet system: %s", str(e))
        wallet_system = None

# Ensure we have a wallet system (fallback to mock if needed)
if not wallet_system:
    logger.warning("‚ö†Ô∏è Using mock wallet system - limited functionality")
    wallet_system = WalletSystem(db) if WalletSystem else None

# Configuration constants
BINANCE_WALLET = os.getenv('BINANCE_WALLET', '')
logger.info("‚úÖ Wallet-based system initialized")

# =============================================================================
# SMSPOOL API INTEGRATION
# =============================================================================

# Global API client - Initialize with enhanced error handling
sms_api = None
try:
    if SMSPOOL_API_KEY and SMSPOOL_API_KEY.strip():
        sms_api = SMSPoolAPI(SMSPOOL_API_KEY)
        logger.info("‚úÖ SMSPool API client initialized successfully")
    else:
        logger.error("‚ùå SMSPOOL_API_KEY is missing or empty")
        logger.warning("‚ö†Ô∏è Running with limited API functionality")
except (ImportError, AttributeError, RuntimeError) as e:
    logger.error("‚ùå Failed to initialize SMSPool API: %s", str(e))
    logger.warning("‚ö†Ô∏è Bot will continue with limited functionality")

# Ensure sms_api is available even if initialization failed
if sms_api is None and WALLET_SYSTEM_AVAILABLE:
    logger.warning("‚ö†Ô∏è Creating fallback SMSPool API instance")
    try:
        sms_api = SMSPoolAPI(SMSPOOL_API_KEY or "fallback_key")
    except (ImportError, AttributeError, RuntimeError) as fallback_error:
        logger.error("‚ùå Fallback API creation failed: %s", fallback_error)
        sms_api = None

# =============================================================================
# OTP POLLING SYSTEM
# =============================================================================

# Store active polling tasks
active_polls: Dict[Union[int, str], asyncio.Task] = {}


async def poll_for_otp(order_id: Union[int, str], user_id: int, context: ContextTypes.DEFAULT_TYPE):
    """Optimized high-frequency OTP polling with intelligent intervals"""
    start_time = datetime.now()
    poll_count = 0
    consecutive_failures = 0
    last_status = None

    try:
        user_logger.info(
            "üîÑ Starting optimized OTP polling for order %s (user: %s)", order_id, user_id)
        performance_logger.info(
            "‚è±Ô∏è OTP polling initiated with adaptive intervals")

        if not sms_api:
            logger.error("‚ùå SMS API not initialized for polling")
            return

        while (datetime.now() - start_time).total_seconds() < POLL_TIMEOUT:
            poll_count += 1
            poll_start = asyncio.get_event_loop().time()

            # Dynamic polling interval based on time elapsed
            elapsed = (datetime.now() - start_time).total_seconds()
            if elapsed < 60:  # First minute: every 2 seconds
                interval = 2
            elif elapsed < 180:  # Next 2 minutes: every 3 seconds
                interval = 3
            elif elapsed < 300:  # Next 2 minutes: every 5 seconds
                interval = 5
            else:  # After 5 minutes: every 10 seconds
                interval = 10

            api_logger.debug(
                "üîç Poll #%s for order %s (interval: %ss)", poll_count, order_id, interval)

            try:
                # Check OTP status with timeout
                result = await asyncio.wait_for(
                    sms_api.get_order_status(str(order_id)),
                    timeout=10.0  # 10 second timeout per API call
                )

                poll_duration = asyncio.get_event_loop().time() - poll_start
                performance_logger.debug(
                    "‚ö° API status check completed in %.2fs", poll_duration)

                consecutive_failures = 0  # Reset failure counter on success

                if result.get('success'):
                    status = result.get('status', '')
                        otp_patterns = [
                            r'\b(\d{6})\b',  # 6-digit codes (most common)
                            r'\b(\d{4})\b',  # 4-digit codes
                            r'\b(\d{5})\b',  # 5-digit codes
                            r'\b(\d{7,8})\b',  # 7-8 digit codes
                            # Pattern with keywords
                            r'(?:code|verification|pin):\s*(\d+)',
                            r'(\d+)',  # Any sequence of digits as fallback
                        ]

                        otp_code = None
                        for pattern in otp_patterns:
                            match = re.search(pattern, otp_text, re.IGNORECASE)
                            if match:
                                otp_code = match.group(1)
                                break

                        otp_code = otp_code or otp_text  # Fallback to full text

                        # Update database with detailed info
                        try:
                            # Update order status with OTP completion
                            db.update_order_status(
                                order_id, 'completed', otp_code)
                            user_logger.info(
                                "‚úÖ Order %s completed - OTP: %s", order_id, otp_code)
                        except (OSError, RuntimeError, ValueError) as db_err:
                            logger.error(
                                "‚ùå Database update failed: %s", db_err)

                        # Send optimized success message to user
                        # Create buttons for after OTP is received
                        success_keyboard = [
                            [
                                InlineKeyboardButton(
                                    "üì± Buy Another", callback_data="browse_services"),
                                InlineKeyboardButton(
                                    "üí∞ Check Balance", callback_data="show_balance")
                            ],
                            [
                                InlineKeyboardButton(
                                    "üÜî Order History", callback_data="transaction_history"),
                                InlineKeyboardButton(
                                    "üè† Main Menu", callback_data="back_to_start")
                            ]
                        ]
                        success_reply_markup = InlineKeyboardMarkup(
                            success_keyboard)

                        if result.get('success'):
                            status = result.get('status', '')

                            # Log status changes for debugging
                            if status != last_status:
                                api_logger.info(
                                    "üìä Order %s status changed: %s ‚Üí %s", order_id, last_status, status)
                                last_status = status
                                
                                # Special logging for processing status (previously thought to be cancelled)
                                if status == 'processing':
                                    api_logger.info(
                                        "üîÑ Order %s is now processing - SMS dispatched, waiting for delivery", order_id)
                                elif status.startswith('unknown_'):
                                    api_logger.warning(
                                        "‚ö†Ô∏è Order %s has unknown status: %s - continuing to poll", order_id, status)

                            # DEBUG: Log full API response for processing and success status
                            if status in ['processing', 'success']:
                                api_logger.info(
                                    "üîç Order %s API response: status=%s, sms=%s, full_response=%s", 
                                    order_id, status, result.get('sms'), result)

                            # SUCCESS: OTP received! (Check both 'success' and 'processing' status)
                            # SMSPool API may return SMS content with status 3 (processing)
                            if status in ['success', 'processing'] and (result.get('sms') or result.get('otp')):
                                otp_text = result.get(
                                    'sms', '') or result.get('otp', '')

                                # Enhanced OTP extraction with multiple patterns
                                otp_patterns = [
                                    # 6-digit codes (most common)
                                    r'\b(\d{6})\b',
                                    r'\b(\d{4})\b',  # 4-digit codes
                                    r'\b(\d{5})\b',  # 5-digit codes
                                    r'\b(\d{7,8})\b',  # 7-8 digit codes
                                    # Pattern with keywords
                                    r'(?:code|verification|pin):\s*(\d+)',
                                    # Any sequence of digits as fallback
                                    r'(\d+)',
                                ]

                                otp_code = None
                                for pattern in otp_patterns:
                                    match = re.search(
                                        pattern, otp_text, re.IGNORECASE)
                                    if match:
                                        otp_code = match.group(1)
                                        break

                                otp_code = otp_code or otp_text  # Fallback to full text

                                # Update database with detailed info
                                try:
                                    # Update order status with OTP completion
                                    db.update_order_status(
                                        order_id, 'completed', otp_code)
                                    user_logger.info(
                                        "\u2705 Order %s completed - OTP: %s", order_id, otp_code)
                                except (OSError, RuntimeError, ValueError) as db_err:
                                    logger.error(
                                        "\u274c Database update failed: %s", db_err)

                                # Send optimized success message to user
                                # Create buttons for after OTP is received
                                success_keyboard = [
                                    [
                                        InlineKeyboardButton(
                                            "\ud83d\udcf1 Buy Another", callback_data="browse_services"),
                                        InlineKeyboardButton(
                                            "\ud83d\udcb0 Check Balance", callback_data="show_balance")
                                    ],
                                    [
                                        InlineKeyboardButton(
                                            "\ud83c\uddfa Order History", callback_data="transaction_history"),
                                        InlineKeyboardButton(
                                            "\ud83c\udfe0 Main Menu", callback_data="back_to_start")
                                    ]
                                ]
                                success_reply_markup = InlineKeyboardMarkup(
                                    success_keyboard)

                                total_time = (datetime.now() -
                                              start_time).total_seconds()
                                await context.bot.send_message(
                                    chat_id=user_id,
                                    text=f"\ud83c\udf89 <b>OTP Code Received!</b>\n\n"
                                    f"\ud83d\udc49 <b>Your Code:</b> <code>{otp_code}</code>\n\n"
                                    f"\ud83d\udcf1 <b>Full SMS:</b> {otp_text}\n\n"
                                    f"\ud83c\uddfa <b>Order:</b> #{order_id}\n"
                                    f"\u26a1 <b>Delivery Time:</b> {total_time:.1f} seconds\n"
                                    f"\ud83d\udd04 <b>Polls Required:</b> {poll_count}\n\n"
                                    f"\u2728 <b>Ready to use immediately!</b>",
                                    parse_mode='HTML',
                                    reply_markup=success_reply_markup
                                )

                                performance_logger.info(
                                    "üéØ OTP delivered for order %s in %.1fs after %s polls", order_id, total_time, poll_count)
                                break
                            
                            # Handle terminal status states (should stop polling)
                            elif status in ['cancelled', 'expired', 'timeout']:
                                api_logger.warning(
                                    "üõë Order %s reached terminal status: %s - stopping polling", order_id, status)
                                
                                # Update database status
                                try:
                                    db.update_order_status(order_id, status)
                                except (OSError, RuntimeError, ValueError) as db_err:
                                    logger.error("‚ùå Database status update failed: %s", db_err)
                                
                                # Notify user about terminal status
                                terminal_keyboard = [
                                    [
                                        InlineKeyboardButton(
                                            "üí∞ Request Refund", callback_data=f"refund_{order_id}"),
                                        InlineKeyboardButton(
                                            "üì± Try Again", callback_data="browse_services")
                                    ],
                                    [
                                        InlineKeyboardButton(
                                            "üí≥ Check Balance", callback_data="show_balance"),
                                        InlineKeyboardButton(
                                            "üè† Main Menu", callback_data="back_to_start")
                                    ]
                                ]
                                terminal_reply_markup = InlineKeyboardMarkup(terminal_keyboard)
                                
                                status_messages = {
                                    'cancelled': 'üö´ <b>Order Cancelled</b>\n\nThis order was cancelled by the provider.',
                                    'expired': '‚è∞ <b>Order Expired</b>\n\nThis order has expired and is no longer active.',
                                    'timeout': 'üïí <b>Order Timeout</b>\n\nThis order timed out waiting for SMS delivery.'
                                }
                                
                                total_time = (datetime.now() - start_time).total_seconds()
                                await context.bot.send_message(
                                    chat_id=user_id,
                                    text=f"{status_messages.get(status, '‚ùå Order Failed')}\n\n"
                                    f"üÜî <b>Order:</b> #{order_id}\n"
                                    f"‚è±Ô∏è <b>Duration:</b> {total_time:.1f} seconds\n"
                                    f"üîÑ <b>Total Polls:</b> {poll_count}\n\n"
                                    f"üí∞ <b>Refund available</b> - Use button below to request refund.",
                                    parse_mode='HTML',
                                    reply_markup=terminal_reply_markup
                                )
                                break
                            
                            # Continue polling for pending/processing statuses
                            # (no action needed - loop will continue)
            except (OSError, RuntimeError, ValueError) as api_error:
                consecutive_failures += 1
                api_logger.error(
                    "‚ùå API error during poll #%s for order %s: %s", poll_count, order_id, str(api_error))

            # Adaptive sleep based on current interval
            await asyncio.sleep(interval)

        else:
            # TIMEOUT: No OTP received within time limit
            try:
                db.update_order_status(order_id, 'timeout')
            except (OSError, RuntimeError, ValueError) as db_err:
                logger.error("‚ùå Database timeout update failed: %s", db_err)

            # Create refund buttons for timeout scenario
            timeout_keyboard = [
                [
                    InlineKeyboardButton(
                        "üí∞ Request Refund", callback_data=f"refund_{order_id}"),
                    InlineKeyboardButton(
                        "üì± Try Again", callback_data="browse_services")
                ],
                [
                    InlineKeyboardButton(
                        "üí≥ Check Balance", callback_data="show_balance"),
                    InlineKeyboardButton(
                        "üè† Main Menu", callback_data="back_to_start")
                ]
            ]
            timeout_reply_markup = InlineKeyboardMarkup(timeout_keyboard)

            total_time = (datetime.now() - start_time).total_seconds()
            await context.bot.send_message(
                chat_id=user_id,
                text=f"‚è∞ <b>SMS Delivery Timeout</b>\n\n"
                f"üÜî <b>Order:</b> #{order_id}\n"
                f"‚è±Ô∏è <b>Duration:</b> {POLL_TIMEOUT//60} minutes\n"
                f"üîÑ <b>Total Polls:</b> {poll_count}\n\n"
                f"üí∞ <b>Automatic refund will be processed</b>\n"
                f"Contact support if you need assistance.",
                parse_mode='HTML',
                reply_markup=timeout_reply_markup
            )

            performance_logger.warning(
                "‚è∞ Order %s timed out after %s polls in %.1fs", order_id, poll_count, total_time)

    except asyncio.CancelledError:
        user_logger.info(
            "üõë OTP polling cancelled for order %s after %s polls", order_id, poll_count)
        raise
    except (OSError, RuntimeError, ValueError) as e:
        logger.error(
            "‚ùå Critical error in OTP polling for order %s: %s", order_id, str(e))
        logger.error("‚ùå Traceback: %s", traceback.format_exc())

        # Safely update database status if possible
        try:
            db.update_order_status(order_id, 'error')
        except (OSError, RuntimeError, ValueError) as db_error:
            logger.error(
                "‚ùå Failed to update order status during error handling: %s", db_error)

        # Send error notification to user with action buttons
        try:
            error_keyboard = [
                [
                    InlineKeyboardButton(
                        "üí∞ Request Refund", callback_data=f"refund_{order_id}"),
                    InlineKeyboardButton(
                        "üì± Try Again", callback_data="browse_services")
                ],
                [
                    InlineKeyboardButton(
                        "üí≥ Check Balance", callback_data="show_balance"),
                    InlineKeyboardButton(
                        "üè† Main Menu", callback_data="back_to_start")
                ]
            ]
            error_reply_markup = InlineKeyboardMarkup(error_keyboard)

            await context.bot.send_message(
                chat_id=user_id,
                text=f"‚ùå <b>System Error</b>\n\n"
                f"üÜî <b>Order:</b> #{order_id}\n"
                f"üîß <b>Error:</b> {str(e)[:100]}...\n"
                f"üîÑ <b>Polls Completed:</b> {poll_count}\n\n"
                f"üí∞ <b>Automatic refund will be processed</b>\n"
                f"Please contact support with Order ID.",
                parse_mode='HTML',
                reply_markup=error_reply_markup
            )
        except (OSError, RuntimeError, ValueError) as send_error:
            logger.error(
                "‚ùå Failed to send error message to user %s: %s", user_id, send_error)

    finally:
        # Clean up polling task
        if order_id in active_polls:
            del active_polls[order_id]
        performance_logger.info(
            "üßπ Polling cleanup completed for order %s", order_id)


def start_otp_polling(order_id: Union[int, str], user_id: int, context: ContextTypes.DEFAULT_TYPE):
    """Start OTP polling task"""
    if order_id in active_polls:
        active_polls[order_id].cancel()

    task = asyncio.create_task(poll_for_otp(order_id, user_id, context))
    active_polls[order_id] = task
    return task

# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================


def clean_html_message(message: str) -> str:
    """Clean HTML tags from error messages and extract meaningful content"""

    # Remove HTML tags
    clean_text = re.sub(r'<[^>]+>', '', message)

    # Replace multiple spaces/newlines with single space
    clean_text = re.sub(r'\s+', ' ', clean_text.strip())

    # Extract specific error patterns
    if 'couldn\'t find an available phone number' in clean_text:
        return 'No Ring4 numbers available at the moment'
    elif 'No numbers available at the moment' in clean_text:
        return 'Ring4 service temporarily unavailable'
    elif 'country & service you have selected is not valid' in clean_text:
        return 'Ring4 service configuration issue'
    elif clean_text and len(clean_text) > 200:
        # Truncate very long messages
        return clean_text[:200] + '...'

    return clean_text or 'Unknown service error'


def is_admin(user_id: int) -> bool:
    """Check if user is an admin"""
    return user_id in ADMIN_IDS


def format_order_info(order: Dict) -> str:
    """Format order information for display"""
    created = datetime.fromisoformat(
        order['created_at']).strftime('%Y-%m-%d %H:%M')
    status_emoji = {
        'pending': 'üü°',
        'processing': 'üîÑ',
        'completed': '‚úÖ',
        'timeout': '‚è∞',
        'refunded': 'üí∞',
        'cancelled': 'üö´',
        'error': '‚ùå'
    }

    return (
        f"{status_emoji.get(order['status'], '‚ùì')} <b>Order #{order['order_id']}</b>\n"
        f"üì± Number: <code>{order['number']}</code>\n"
        f"üí∞ Cost: ${order['cost']}\n"
        f"üìÖ Created: {created}\n"
        f"üîÑ Status: {order['status'].title()}"
    )

# =============================================================================
# TELEGRAM COMMAND HANDLERS
# =============================================================================


async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle /start command with wallet integration"""
    _ = context  # Acknowledge unused parameter
    if not update.effective_user or not update.message:
        return

    user = update.effective_user
    user_balance = wallet_system.get_user_balance(
        user.id) if wallet_system else 0.00

    # Create wallet-aware buttons
    if user_balance >= 0.15:  # Minimum service price
        keyboard = [[
            InlineKeyboardButton("ÔøΩ Browse Services",
                                 callback_data="browse_services"),
            InlineKeyboardButton(
                "üí∞ Check Balance", callback_data="show_balance")
        ]]
    else:
        keyboard = [[
            InlineKeyboardButton("üí∞ Add Funds (Start Here)",
                                 callback_data="deposit_funds"),
            InlineKeyboardButton("üì± Browse Services",
                                 callback_data="browse_services")
        ]]

    reply_markup = InlineKeyboardMarkup(keyboard)

    welcome_text = (
        f"üëã <b>Welcome to Ring4 SMS Bot!</b>\n\n"
        f"üéØ <b>US Phone Numbers for Verification</b>\n"
        f"üí≥ <b>Your Balance:</b> ${user_balance:.2f}\n\n"
        f"‚ú® <b>New Wallet System:</b>\n"
        f"‚Ä¢ Minimum deposit: $5.00\n"
        f"‚Ä¢ Instant service purchases\n"
        f"‚Ä¢ Automatic refunds to wallet\n"
        f"‚Ä¢ No payment delays\n\n"
        f"üì± <b>Available Services:</b>\n"
        f"‚Ä¢ Ring4 (Recommended) ~$0.17\n"
        f"‚Ä¢ Telegram, Google, WhatsApp\n"
        f"‚Ä¢ Real-time OTP delivery\n"
        f"‚Ä¢ 10-minute validity period\n\n"
    )

    if user_balance < 0.15:
        welcome_text += "üí° <b>Get Started:</b> Add funds to your wallet first!"
    else:
        welcome_text += "üöÄ <b>Ready to go!</b> Browse services to purchase instantly."

    await update.message.reply_text(
        welcome_text,
        parse_mode='HTML',
        reply_markup=reply_markup
    )

    username = user.username or "Unknown"
    logger.info(
        "üëã Start command from user %s (@%s) - Balance: $%.2f", user.id, username, user_balance)


async def handle_start_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle start menu callback - shows main menu"""
    if not update.effective_user:
        return

    user = update.effective_user
    user_balance = wallet_system.get_user_balance(
        user.id) if wallet_system else 0.00

    # Create wallet-aware buttons
    if user_balance >= 0.15:  # Minimum service price
        keyboard = [[
            InlineKeyboardButton("üì± Browse Services",
                                 callback_data="browse_services"),
            InlineKeyboardButton(
                "üí∞ Check Balance", callback_data="show_balance")
        ]]
    else:
        keyboard = [[
            InlineKeyboardButton("üí∞ Add Funds (Start Here)",
                                 callback_data="deposit_funds"),
            InlineKeyboardButton("üì± Browse Services",
                                 callback_data="browse_services")
        ]]

    reply_markup = InlineKeyboardMarkup(keyboard)

    welcome_text = (
        f"üëã <b>Welcome to Ring4 SMS Bot!</b>\n\n"
        f"üéØ <b>US Phone Numbers for Verification</b>\n"
        f"üí≥ <b>Your Balance:</b> ${user_balance:.2f}\n\n"
        f"‚ú® <b>New Wallet System:</b>\n"
        f"‚Ä¢ Minimum deposit: $5.00\n"
        f"‚Ä¢ Instant service purchases\n"
        f"‚Ä¢ Automatic refunds to wallet\n"
        f"‚Ä¢ No payment delays\n\n"
        f"üì± <b>Available Services:</b>\n"
        f"‚Ä¢ Ring4 (Recommended) ~$0.17\n"
        f"‚Ä¢ Telegram, Google, WhatsApp\n"
        f"‚Ä¢ Real-time OTP delivery\n"
        f"‚Ä¢ 10-minute validity period\n\n"
    )

    if user_balance < 0.15:
        welcome_text += "üí° <b>Get Started:</b> Add funds to your wallet first!"
    else:
        welcome_text += "üöÄ <b>Ready to go!</b> Browse services to purchase instantly."

    # Try to edit the message, fallback to new message if needed
    try:
        query = update.callback_query
        if query:
            await query.edit_message_text(
                welcome_text,
                parse_mode='HTML',
                reply_markup=reply_markup
            )
            await query.answer()
        else:
            if update.message:
                await update.message.reply_text(
                    welcome_text,
                    parse_mode='HTML',
                    reply_markup=reply_markup
                )
    except (RuntimeError, ValueError, AttributeError) as e:
        logger.error("Error showing start menu: %s", e)
        # Fallback to new message
        if update.effective_chat:
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text=welcome_text,
                parse_mode='HTML',
                reply_markup=reply_markup
            )


async def buy_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle /buy command (alternative to button)"""
    await handle_buy_ring4(update, context)


async def help_command(update: Update, _context: ContextTypes.DEFAULT_TYPE):
    """Handle /help command"""
    if not update.message:
        return

    help_text = (
        "üìö <b>Ring4 SMS Bot - Help</b>\n\n"
        "<b>Available Commands:</b>\n"
        "‚Ä¢ /start - Welcome message and main menu\n"
        "‚Ä¢ /buy - Purchase a US phone number\n"
        "‚Ä¢ /refund - Request refund for orders\n"
        "‚Ä¢ /help - Show this help message\n\n"
        "<b>How it works:</b>\n"
        "1. Click 'Buy Ring4 Number' or use /buy\n"
        "2. Number is delivered instantly\n"
        "3. Use the number for verification\n"
        "4. OTP code is sent automatically (up to 10 min)\n"
        "5. Request refund if no OTP received\n\n"
        "<b>Service Information:</b>\n"
        "‚Ä¢ Primary: Ring4 service (~$0.17)\n"
        "‚Ä¢ Backup: Alternative services if Ring4 unavailable\n"
        "‚Ä¢ You'll be notified if backup service is used\n"
        "‚Ä¢ Price may vary based on service availability\n\n"
        "<b>Admin Commands:</b>\n"
        "‚Ä¢ /admin - Admin panel (admin only)\n"
        "‚Ä¢ /services - Check service status (admin only)\n"
        "‚Ä¢ /approve_refund - Process refunds (admin only)\n\n"
        "üí° <b>Need help?</b> Contact an administrator."
    )

    await update.message.reply_text(help_text, parse_mode='HTML')


async def refund_command(update: Update, _context: ContextTypes.DEFAULT_TYPE):
    """Handle /refund command"""
    if not update.effective_user or not update.message:
        return

    user_id = update.effective_user.id

    # Get user's refundable orders (pending, timeout, error, cancelled)
    orders = db.get_user_orders(user_id)
    refundable = [o for o in orders if o['status']
                  in ['pending', 'timeout', 'error', 'cancelled']]

    if not refundable:
        await update.message.reply_text(
            "üí∞ <b>No Refundable Orders</b>\n\n"
            "You don't have any orders eligible for refund.\n"
            "Only pending, cancelled, timed out, or error orders can be refunded.",
            parse_mode='HTML'
        )
        return

    keyboard = []
    for order in refundable:
        keyboard.append([
            InlineKeyboardButton(
                f"üí∞ Refund #{order['order_id']} (${order['cost']})",
                callback_data=f"refund_{order['order_id']}"
            )
        ])

    reply_markup = InlineKeyboardMarkup(keyboard)

    refund_text = (
        "üí∞ <b>Request Refund</b>\n\n"
        "Select an order to request a refund.\n"
        "Refunds require admin approval.\n\n"
        f"<b>Refundable Orders:</b> {len(refundable)}"
    )

    await update.message.reply_text(
        refund_text,
        parse_mode='HTML',
        reply_markup=reply_markup
    )


async def admin_command(update: Update, _context: ContextTypes.DEFAULT_TYPE):
    """Handle /admin command (admin only)"""
    if not update.effective_user or not update.message:
        return

    user_id = update.effective_user.id

    if not is_admin(user_id):
        await update.message.reply_text("‚ùå This command is for administrators only.")
        return

    # Get system statistics
    all_orders = db.orders.all()
    pending_refunds = db.get_pending_refunds()

    # Count by status
    status_counts = {}
    total_revenue = 0
    for order in all_orders:
        status = order['status']
        status_counts[status] = status_counts.get(status, 0) + 1
        if status == 'completed':
            try:
                total_revenue += float(order['cost'])
            except (ValueError, TypeError, KeyError):
                pass

    keyboard = []
    if pending_refunds:
        keyboard.append([
            InlineKeyboardButton(
                f"üí∞ Process Refunds ({len(pending_refunds)})",
                callback_data="admin_refunds"
            )
        ])

    reply_markup = InlineKeyboardMarkup(keyboard) if keyboard else None

    admin_text = (
        f"üë®‚Äçüíº <b>Admin Panel</b>\n\n"
        f"üìä <b>System Statistics:</b>\n"
        f"‚Ä¢ Total Orders: {len(all_orders)}\n"
        f"‚Ä¢ Completed: {status_counts.get('completed', 0)}\n"
        f"‚Ä¢ Pending: {status_counts.get('pending', 0)}\n"
        f"‚Ä¢ Timeout: {status_counts.get('timeout', 0)}\n"
        f"‚Ä¢ Refunded: {status_counts.get('refunded', 0)}\n"
        f"‚Ä¢ Errors: {status_counts.get('error', 0)}\n\n"
        f"üí∞ <b>Revenue:</b> ${total_revenue:.2f}\n"
        f"üîÑ <b>Active Polls:</b> {len(active_polls)}\n"
        f"üí∏ <b>Pending Refunds:</b> {len(pending_refunds)}\n\n"
        f"ü§ñ <b>Bot Status:</b> ‚úÖ Running"
    )

    if reply_markup:
        await update.message.reply_text(
            admin_text,
            parse_mode='HTML',
            reply_markup=reply_markup
        )
    else:
        await update.message.reply_text(
            admin_text,
            parse_mode='HTML'
        )


async def balance_command(update: Update, _context: ContextTypes.DEFAULT_TYPE):
    """Handle /balance command - Show user's wallet balance and recent transactions"""
    # Handle both direct messages and callback queries
    if update.callback_query:
        query = update.callback_query
        user = query.from_user
        await query.answer()
        send_method = query.edit_message_text
    elif update.message:
        user = update.effective_user
        send_method = update.message.reply_text
    else:
        return

    if not user:
        return
    user_id = user.id

    if not wallet_system:
        if update.callback_query:
            await update.callback_query.edit_message_text("‚ùå Wallet system not available.")
        elif update.message:
            await update.message.reply_text("‚ùå Wallet system not available.")
        return

    try:
        # Get wallet summary
        wallet_summary = wallet_system.get_wallet_summary(user_id)

        # Format balance information
        balance_text = (
            f"üí∞ <b>Your Wallet Balance</b>\n\n"
            f"üíµ <b>Current Balance:</b> ${wallet_summary['balance']:.2f}\n\n"
            f"üìä <b>Statistics:</b>\n"
            f"‚Ä¢ Total Deposited: ${wallet_summary['total_deposited']:.2f}\n"
            f"‚Ä¢ Total Spent: ${wallet_summary['total_spent']:.2f}\n"
            f"‚Ä¢ Total Refunded: ${wallet_summary['total_refunded']:.2f}\n\n"
        )

        # Add recent transactions
        recent_transactions = wallet_summary['recent_transactions']
        if recent_transactions:
            balance_text += "üìä <b>Recent Transactions:</b>\n"
            for tx in recent_transactions[:5]:  # Show last 5 transactions
                tx_type_emoji = {
                    'deposit': 'üí∞',
                    'deduction': 'üí∏',
                    'refund': 'üí´',
                    'admin_credit': 'üéÅ'
                }
                emoji = tx_type_emoji.get(tx['transaction_type'], 'üìÑ')
                amount_sign = '+' if tx['transaction_type'] in [
                    'deposit', 'refund', 'admin_credit'] else '-'

                # Format timestamp
                tx_time = datetime.fromisoformat(
                    tx['timestamp']).strftime('%m/%d %H:%M')

                balance_text += (
                    f"{emoji} {amount_sign}${tx['amount']:.2f} - {tx['description'][:30]}{'...' if len(tx['description']) > 30 else ''}\n"
                    f"   <i>{tx_time} | Balance: ${tx['balance_after']:.2f}</i>\n"
                )
        else:
            balance_text += "üìù <b>No transactions yet</b>\n"

        # Add action buttons
        keyboard = []

        # Add deposit button if balance is low
        if wallet_summary['balance'] < 5.00:
            keyboard.append([
                InlineKeyboardButton(
                    "üí∞ Add Funds (Min: $5)", callback_data="deposit_funds")
            ])
        else:
            keyboard.append([
                InlineKeyboardButton("üí∞ Add More Funds",
                                     callback_data="deposit_funds")
            ])

        keyboard.append([
            InlineKeyboardButton("üì± Browse Services",
                                 callback_data="browse_services"),
            InlineKeyboardButton(
                "üìä Full History", callback_data="transaction_history")
        ])

        reply_markup = InlineKeyboardMarkup(keyboard)

        await send_method(
            balance_text,
            parse_mode='HTML',
            reply_markup=reply_markup
        )

        logger.info(
            "üí∞ Balance checked by user %s: $%.2f", user_id, wallet_summary['balance'])

    except RuntimeError as e:
        logger.error("‚ùå Error showing balance for user %s: %s",
                     user_id, str(e))
        error_msg = "‚ùå Error retrieving balance information. Please try again."
        if update.callback_query:
            await update.callback_query.edit_message_text(error_msg)
        elif update.message:
            await update.message.reply_text(error_msg)


async def approve_refund_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle /approve_refund command (admin only) - Approve specific refund requests"""
    if not update.effective_user or not update.message:
        return

    user_id = update.effective_user.id

    if not is_admin(user_id):
        await update.message.reply_text("‚ùå This command is for administrators only.")
        return

    # Extract order ID from command arguments
    args = context.args
    if not args:
        await update.message.reply_text(
            "‚ùå Please provide an order ID.\n"
            "Usage: /approve_refund <order_id>"
        )
        return

    order_id = args[0]  # Keep as string, don't convert to int

    # Check if refund request exists
    pending_refunds = db.get_pending_refunds()
    refund_request = None
    for refund in pending_refunds:
        if refund.get('order_id') == order_id:
            refund_request = refund
            break

    if not refund_request:
        await update.message.reply_text(f"‚ùå No pending refund request found for order ID {order_id}.")
        return

    # Get the original order
    order = db.get_order(order_id)
    if not order:
        await update.message.reply_text(f"‚ùå Order {order_id} not found in database.")
        return

    try:
        # Process the refund
        db.update_refund_status(order_id, 'approved', user_id)
        db.update_order_status(order_id, 'refunded')

        # Cancel the order with SMSPool if API is available
        if sms_api and order.get('order_id'):
            cancel_result = await sms_api.cancel_order(str(order['order_id']))
            if cancel_result.get('success'):
                logger.info(
                    "‚úÖ Order %s cancelled with SMSPool", order['order_id'])
            else:
                logger.warning(
                    "‚ö†Ô∏è Failed to cancel order %s with SMSPool: %s", order['order_id'], cancel_result.get('message'))

        # Notify the user
        try:
            await context.bot.send_message(
                chat_id=refund_request['user_id'],
                text=(
                    f"‚úÖ <b>Refund Approved</b>\n\n"
                    f"Your refund request for order #{order_id} has been approved.\n"
                    f"Amount: ${order.get('cost', 'N/A')}\n\n"
                    f"The refund will be processed according to our refund policy."
                ),
                parse_mode='HTML'
            )
        except RuntimeError as notify_error:
            logger.error(
                "‚ùå Failed to notify user %s about refund approval: %s", refund_request['user_id'], notify_error)

        await update.message.reply_text(
            f"‚úÖ <b>Refund Approved</b>\n\n"
            f"Order ID: {order_id}\n"
            f"User ID: {refund_request['user_id']}\n"
            f"Amount: ${order.get('cost', 'N/A')}\n"
            f"Approved by: {update.effective_user.first_name}\n\n"
            f"User has been notified automatically.",
            parse_mode='HTML'
        )

        logger.info(
            "‚úÖ Refund approved for order %s by admin %s", order_id, user_id)

    except RuntimeError as e:
        logger.error(
            "‚ùå Error processing refund approval for order %s: %s", order_id, str(e))
        await update.message.reply_text(
            f"‚ùå Error processing refund approval: {str(e)}\n"
            "Please try again or contact system administrator."
        )


async def service_status_command(update: Update, _context: ContextTypes.DEFAULT_TYPE):
    """Handle /services command (admin only) - Check service availability and pricing"""
    if not update.effective_user or not update.message:
        return

    user_id = update.effective_user.id

    if not is_admin(user_id):
        await update.message.reply_text("‚ùå This command is for administrators only.")
        return

    if not sms_api:
        await update.message.reply_text("‚ùå SMS API not initialized.")
        return

    # Show loading message
    loading_msg = await update.message.reply_text("üîÑ Checking service availability and pricing...")

    try:
        # Get pricing for all services
        pricing_info = await sms_api.get_service_pricing()

        if not pricing_info.get('success'):
            await loading_msg.edit_text("‚ùå Failed to get service pricing information.")
            return

        # Build status message
        status_text = "üìä <b>Service Status & Pricing</b>\n\n"

        # Ring4 specific status
        ring4_status = pricing_info.get('ring4_status')
        if ring4_status:
            status_icon = "‚úÖ" if ring4_status['available'] else "‚ùå"
            status_text += f"{status_icon} <b>Ring4 (Primary):</b> "
            if ring4_status['available']:
                status_text += f"${ring4_status['price']}\n"
            else:
                status_text += "Unavailable\n"

        status_text += "\n<b>Alternative Services:</b>\n"

        # Show all services
        for service in pricing_info.get('all_services', []):
            if service['id'] == 1574:  # Skip Ring4 as we already showed it
                continue

            status_icon = "‚úÖ" if service['available'] else "‚ùå"
            status_text += f"{status_icon} {service['name']}: "
            if service['available']:
                status_text += f"${service['price']}\n"
            else:
                status_text += "Unavailable\n"

        # Show cheapest available
        cheapest = pricing_info.get('cheapest_available')
        if cheapest:
            status_text += f"\nüí∞ <b>Cheapest Available:</b> {cheapest['name']} (${cheapest['price']})\n"

        # Show recommendations
        available_count = len(pricing_info.get('available_services', []))
        status_text += "\nüìà <b>Summary:</b>\n"
        status_text += f"‚Ä¢ Available services: {available_count}/4\n"

        if ring4_status and not ring4_status['available']:
            if cheapest:
                # Expected Ring4 price
                price_diff = float(cheapest['price']) - 0.17
                status_text += f"‚Ä¢ Price impact: +${price_diff:.2f} per order\n"
                status_text += "‚Ä¢ Recommend adjusting user pricing or waiting for Ring4\n"
        else:
            status_text += "‚Ä¢ Ring4 available: No pricing adjustments needed\n"

        await loading_msg.edit_text(status_text, parse_mode='HTML')

        logger.info("‚úÖ Service status checked by admin %s", user_id)

    except RuntimeError as e:
        logger.error("‚ùå Error checking service status: %s", str(e))
        await loading_msg.edit_text(
            f"‚ùå Error checking service status: {str(e)}\n"
            "Please try again later."
        )


async def handle_deposit_funds(update: Update, _context: ContextTypes.DEFAULT_TYPE):
    """Handle deposit funds request"""
    if not update.callback_query:
        return

    query = update.callback_query
    user = update.effective_user

    if not query or not user:
        return

    await query.answer()

    if not wallet_system:
        await query.edit_message_text("‚ùå Wallet system not available.")
        return

    # Show deposit amount options
    keyboard = [
        [
            InlineKeyboardButton("üí∞ $5.00 (Minimum)",
                                 callback_data="deposit_amount_5.00"),
            InlineKeyboardButton(
                "üí∞ $10.00", callback_data="deposit_amount_10.00")
        ],
        [
            InlineKeyboardButton(
                "üí∞ $25.00", callback_data="deposit_amount_25.00"),
            InlineKeyboardButton(
                "üí∞ $50.00", callback_data="deposit_amount_50.00")
        ],
        [
            InlineKeyboardButton(
                "üí∞ $100.00", callback_data="deposit_amount_100.00"),
            InlineKeyboardButton(
                "üî¢ Custom Amount", callback_data="deposit_custom")
        ],
        [
            InlineKeyboardButton("üîô Back to Balance",
                                 callback_data="show_balance")
        ]
    ]

    reply_markup = InlineKeyboardMarkup(keyboard)

    deposit_text = (
        f"üí∞ <b>Add Funds to Wallet</b>\n\n"
        f"Choose deposit amount:\n\n"
        f"üí° <b>Benefits:</b>\n"
        f"‚Ä¢ Instant service purchases\n"
        f"‚Ä¢ No payment delays\n"
        f"‚Ä¢ Automatic refunds to wallet\n"
        f"‚Ä¢ Track spending history\n\n"
        f"üìã <b>Deposit Range:</b>\n"
        f"‚Ä¢ Minimum: ${wallet_system.MIN_DEPOSIT_USD:.2f}\n"
        f"‚Ä¢ Maximum: ${wallet_system.MAX_DEPOSIT_USD:.2f}\n\n"
        f"üè¶ All deposits require admin verification"
    )

    await query.edit_message_text(
        deposit_text,
        parse_mode='HTML',
        reply_markup=reply_markup
    )


async def handle_deposit_custom(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle custom deposit amount request"""
    if not update.callback_query:
        return

    query = update.callback_query
    user = update.effective_user

    if not query or not user:
        return

    await query.answer()

    # Ask user to send custom amount
    custom_text = (
        f"üí∞ <b>Custom Deposit Amount</b>\n\n"
        f"üí° Please send your desired deposit amount as a message.\n\n"
        f"<b>Requirements:</b>\n"
        f"‚Ä¢ Minimum: ${wallet_system.MIN_DEPOSIT_USD if wallet_system else 5.00}\n"
        f"‚Ä¢ Format: Enter amount only (e.g., 10.50)\n"
        f"‚Ä¢ No symbols ($ or USD)\n\n"
        f"üìù <b>Example:</b> Send \"10.50\" for $10.50\n\n"
        f"‚ùå Send /cancel to abort"
    )

    keyboard = [[
        InlineKeyboardButton("‚ùå Cancel", callback_data="deposit_funds")
    ]]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text(
        custom_text,
        parse_mode='HTML',
        reply_markup=reply_markup
    )

    # Set user state to expect custom amount
    if context.user_data is not None:
        context.user_data['awaiting_deposit_amount'] = True
    logger.info("üí∞ User %s requested custom deposit amount", user.id)


async def handle_deposit_amount(update: Update, _context: ContextTypes.DEFAULT_TYPE):
    """Handle deposit amount selection"""
    if not update.callback_query:
        return

    query = update.callback_query
    user = update.effective_user

    if not query or not user:
        return

    await query.answer()

    if not wallet_system:
        await query.edit_message_text("‚ùå Wallet system not available.")
        return

    try:
        # Extract amount from callback data
        callback_data = query.data
        if not callback_data:
            await query.edit_message_text("‚ùå Invalid callback data.")
            return

        if callback_data.startswith("deposit_amount_"):
            amount = float(callback_data.split("_")[-1])
        else:
            await query.edit_message_text("‚ùå Invalid amount selection.")
            return

        # Create deposit request
        deposit_request = wallet_system.create_deposit_request(
            user_id=user.id,
            amount=amount,
            binance_wallet=BINANCE_WALLET
        )

        # Format deposit instructions
        instructions_text = "üí∞ <b>Wallet Deposit Request</b>\n\n"
        instructions_text += "\n".join(deposit_request['instructions'])

        keyboard = [[
            InlineKeyboardButton(
                "‚úÖ Payment Sent", callback_data=f"deposit_sent_{deposit_request['deposit_id']}"),
            InlineKeyboardButton("‚ùå Cancel", callback_data="cancel_deposit")
        ]]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.edit_message_text(
            instructions_text,
            parse_mode='Markdown',
            reply_markup=reply_markup
        )

        logger.info("üí∞ Deposit request created for user %s: $%s",
                    user.id, amount)

    except ValueError as e:
        await query.edit_message_text(
            f"‚ùå <b>Invalid Deposit Amount</b>\n\n"
            f"Error: {str(e)}\n\n"
            f"Please try again with a valid amount.",
            parse_mode='HTML'
        )
    except RuntimeError as e:
        logger.error("‚ùå Error creating deposit request: %s", str(e))
        await query.edit_message_text(
            "‚ùå Error creating deposit request. Please try again."
        )


async def handle_service_purchase_with_wallet(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle service purchase using wallet balance"""
    query = update.callback_query
    user = update.effective_user

    if not query or not user:
        return

    await query.answer()

    try:
        # Extract service info from callback data
        callback_data = query.data
        if not callback_data:
            logger.error("‚ùå No callback data received")
            return

        parts = callback_data.split('_')
        service_id = int(parts[2])
        selling_price = float(parts[3])

        # Get service name
        service_names = {1574: 'Ring4', 22: 'Telegram',
                         395: 'Google', 1012: 'WhatsApp'}
        service_name = service_names.get(service_id, f'Service {service_id}')

        # Check wallet balance
        if not wallet_system:
            await query.edit_message_text(
                "‚ùå Wallet system not available. Please try again later.",
                parse_mode='HTML'
            )
            return

        user_balance = wallet_system.get_user_balance(user.id)

        if user_balance < selling_price:
            # Insufficient balance - show deposit options
            needed_amount = selling_price - user_balance

            keyboard = [
                [InlineKeyboardButton(
                    "üí∞ Add Funds", callback_data="deposit_funds")],
                [InlineKeyboardButton(
                    "üîô Back to Services", callback_data="browse_services")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await query.edit_message_text(
                f"üí∞ <b>Insufficient Wallet Balance</b>\n\n"
                f"üì± <b>Service:</b> {service_name}\n"
                f"üíµ <b>Price:</b> ${selling_price:.2f}\n"
                f"üí≥ <b>Your Balance:</b> ${user_balance:.2f}\n"
                f"‚ùå <b>Needed:</b> ${needed_amount:.2f}\n\n"
                f"Please add funds to your wallet to continue.",
                parse_mode='HTML',
                reply_markup=reply_markup
            )
            return

        # Sufficient balance - proceed with purchase
        await query.edit_message_text(
            f"üîÑ <b>Processing {service_name} Purchase</b>\n\n"
            f"üí∞ <b>Price:</b> ${selling_price:.2f}\n"
            f"üí≥ <b>Wallet Balance:</b> ${user_balance:.2f}\n"
            f"üì± <b>Service:</b> {service_name}\n\n"
            f"‚ö° Purchasing your US number...",
            parse_mode='HTML'
        )

        # Process the purchase
        await process_wallet_purchase(user.id, context, query.edit_message_text, service_id, service_name, selling_price)

    except RuntimeError as e:
        logger.error("‚ùå Error in wallet-based service purchase: %s", str(e))
        await query.edit_message_text(
            "‚ùå Error processing purchase. Please try again.",
            parse_mode='HTML'
        )


async def process_wallet_purchase(user_id: int, context: ContextTypes.DEFAULT_TYPE, send_method, service_id: int, service_name: str, selling_price: float):
    """Process service purchase using wallet balance"""

    purchase_logger.info(
        "üöÄ Starting wallet purchase for user %s: %s ($%.2f)", user_id, service_name, selling_price)

    start_time = asyncio.get_event_loop().time()
    order_id = None

    try:
        # Step 1: Deduct from wallet balance first
        if not wallet_system:
            await send_method(
                "‚ùå Wallet system not available. Please try again later.",
                parse_mode='HTML'
            )
            return

        deduction_success = wallet_system.deduct_balance(
            user_id=user_id,
            amount=selling_price,
            description=f"{service_name} service purchase",
            order_id=None  # Will update with order_id later
        )

        if not deduction_success:
            await send_method(
                f"‚ùå <b>Payment Failed</b>\n\n"
                f"Unable to deduct ${selling_price:.2f} from your wallet.\n"
                f"Please check your balance and try again.",
                parse_mode='HTML'
            )
            return

        # Step 2: Purchase the SMS number
        if not sms_api:
            # Refund the balance if SMS API is not available
            wallet_system.add_balance(
                user_id=user_id,
                amount=selling_price,
                description=f"Refund for failed {service_name} purchase - SMS API unavailable",
                transaction_type='refund'
            )
            await send_method(
                f"‚ùå <b>Service Unavailable</b>\n\n"
                f"SMS service is currently unavailable.\n"
                f"${selling_price:.2f} has been refunded to your wallet.",
                parse_mode='HTML'
            )
            return

        # Show updated balance
        new_balance = wallet_system.get_user_balance(user_id)
        await send_method(
            f"‚úÖ <b>Payment Processed</b>\n\n"
            f"üí∞ <b>Deducted:</b> ${selling_price:.2f}\n"
            f"üí≥ <b>New Balance:</b> ${new_balance:.2f}\n"
            f"üì± <b>Service:</b> {service_name}\n\n"
            f"üîÑ Acquiring your US number...",
            parse_mode='HTML'
        )

        # Purchase the SMS number
        purchase_result = await sms_api.purchase_specific_service(
            service_id=service_id,
            service_name=service_name
        )

        if not purchase_result.get('success'):
            # Refund the balance
            wallet_system.add_balance(
                user_id=user_id,
                amount=selling_price,
                description=f"Refund for failed {service_name} purchase - {purchase_result.get('error', 'Purchase failed')}",
                transaction_type='refund'
            )

            await send_method(
                f"‚ùå <b>Purchase Failed</b>\n\n"
                f"Error: {purchase_result.get('error', 'Unknown error')}\n"
                f"üí∞ ${selling_price:.2f} has been refunded to your wallet.\n\n"
                f"Please try again or contact support.",
                parse_mode='HTML'
            )
            return

        # Success - create order record
        order_id = purchase_result.get('order_id')
        phone_number = purchase_result.get('number')
        actual_cost = purchase_result.get('cost', selling_price)

        # Create order in database
        order_data = {
            'order_id': order_id,
            'number': phone_number,
            'cost': selling_price,  # What user paid from wallet
            'actual_cost': actual_cost,  # What SMS provider charged
            'service_name': service_name,
            'service_id': service_id
        }

        db.create_order(user_id, order_data)

        # Send success message with number
        total_time = asyncio.get_event_loop().time() - start_time
        keyboard = [[
            InlineKeyboardButton(
                "‚ùå Cancel Order", callback_data=f"cancel_order_{order_id}")
        ]]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await send_method(
            f"üéâ <b>{service_name} Number Acquired!</b>\n\n"
            f"üì± <b>Your Number:</b> <code>{phone_number}</code>\n"
            f"üí∞ <b>Cost:</b> ${selling_price:.2f}\n"
            f"üí≥ <b>Wallet Balance:</b> ${new_balance:.2f}\n"
            f"üÜî <b>Order ID:</b> <code>{order_id}</code>\n\n"
            f"‚è∞ <b>Valid for 10 minutes</b>\n"
            f"üîÑ <b>OTP monitoring started</b>\n\n"
            f"‚ö° <i>Acquired in {total_time:.1f} seconds</i>\n\n"
            f"Use this number for verification. You'll get the OTP automatically!",
            parse_mode='HTML',
            reply_markup=reply_markup
        )

        # Start OTP polling if order_id is valid
        if order_id:
            start_otp_polling(order_id, user_id, context)
        else:
            logger.warning("‚ö†Ô∏è No order_id available for OTP polling")

        purchase_logger.info(
            "‚úÖ Wallet purchase completed for user %s: %s", user_id, order_id)

    except RuntimeError as e:
        total_time = asyncio.get_event_loop().time() - start_time
        purchase_logger.error(
            "‚ùå Exception during wallet purchase for user %s after %.2fs: %s", user_id, total_time, str(e))

        # Try to refund if we deducted money
        try:
            if wallet_system:
                wallet_system.add_balance(
                    user_id=user_id,
                    amount=selling_price,
                    description=f"Refund for failed {service_name} purchase - Exception: {str(e)[:50]}",
                    transaction_type='refund'
                )
        except RuntimeError as refund_error:
            logger.error("‚ùå Failed to refund user %s: %s",
                         user_id, refund_error)

        await send_method(
            f"‚ùå <b>Purchase Error</b>\n\n"
            f"An error occurred during purchase.\n"
            f"üí∞ ${selling_price:.2f} has been refunded to your wallet.\n\n"
            f"Please try again or contact support if the issue persists.",
            parse_mode='HTML'
        )


async def handle_deposit_sent(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle when user claims deposit is sent"""
    query = update.callback_query
    if not query or not query.from_user:
        return

    # Extract deposit ID from callback data: "deposit_sent_DEP_123456789_1754854768"
    if not query.data:
        await query.answer("‚ùå Invalid request.")
        return

    # Get "DEP_123456789_1754854768"
    deposit_id = "_".join(query.data.split('_')[2:])
    user = query.from_user

    await query.answer()

    # Notify all admins about deposit claim
    for admin_id in ADMIN_IDS:
        try:
            keyboard = [[
                InlineKeyboardButton(
                    "‚úÖ Approve", callback_data=f"approve_deposit_{deposit_id}"),
                InlineKeyboardButton(
                    "‚ùå Deny", callback_data=f"deny_deposit_{deposit_id}")
            ]]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await context.bot.send_message(
                chat_id=admin_id,
                text=(
                    f"üí∞ <b>New Deposit Claim</b>\n\n"
                    f"üë§ <b>User:</b> {user.id} (@{user.username or 'Unknown'})\n"
                    f"üÜî <b>Deposit ID:</b> <code>{deposit_id}</code>\n\n"
                    f"‚ö†Ô∏è <b>Action Required:</b> Verify payment and approve/deny"
                ),
                parse_mode='HTML',
                reply_markup=reply_markup
            )
        except RuntimeError as e:
            logger.error("Failed to notify admin %s: %s", admin_id, e)

    await query.edit_message_text(
        f"‚úÖ <b>Deposit Claim Submitted</b>\n\n"
        f"üÜî <b>Deposit ID:</b> <code>{deposit_id}</code>\n\n"
        f"üë®‚Äçüíº Admins have been notified and will verify your payment.\n"
        f"‚è∞ You'll be notified once the deposit is approved.\n\n"
        f"üí° <b>Note:</b> Only send the exact amount to avoid delays.",
        parse_mode='HTML'
    )

    logger.info("üí∞ Deposit claim submitted by user %s: %s",
                user.id, deposit_id)


async def handle_cancel_deposit(update: Update, _context: ContextTypes.DEFAULT_TYPE):
    """Handle deposit cancellation"""
    query = update.callback_query
    if not query:
        return

    await query.answer()

    await query.edit_message_text(
        "‚ùå <b>Deposit Cancelled</b>\n\n"
        "You can start a new deposit anytime using /balance or the wallet menu.",
        parse_mode='HTML'
    )

    user_id = query.from_user.id if query.from_user else "Unknown"
    logger.info("üí∞ Deposit cancelled by user %s", user_id)


async def handle_transaction_history(update: Update, _context: ContextTypes.DEFAULT_TYPE):
    """Show full transaction history"""
    if not update.callback_query:
        return

    query = update.callback_query
    user = update.effective_user

    if not query or not user:
        return

    await query.answer()

    if not wallet_system:
        await query.edit_message_text("‚ùå Wallet system not available.")
        return

    # Get full transaction history
    transactions = wallet_system.get_transaction_history(user.id, limit=20)

    if not transactions:
        await query.edit_message_text(
            "üìù <b>Transaction History</b>\n\n"
            "No transactions found.\n\n"
            "üí° Add funds to start using the service!",
            parse_mode='HTML'
        )
        return

    # Format transaction history
    history_text = "üìù <b>Transaction History</b>\n\n"

    for tx in transactions:
        tx_type_emoji = {
            'deposit': 'üí∞',
            'deduction': 'üí∏',
            'refund': 'üí´',
            'admin_credit': 'üéÅ'
        }
        emoji = tx_type_emoji.get(tx['transaction_type'], 'üìÑ')
        amount_sign = '+' if tx['transaction_type'] in ['deposit',
                                                        'refund', 'admin_credit'] else '-'

        # Format timestamp
        tx_time = datetime.fromisoformat(
            tx['timestamp']).strftime('%m/%d/%y %H:%M')

        history_text += (
            f"{emoji} <b>{amount_sign}${tx['amount']:.2f}</b>\n"
            f"   {tx['description']}\n"
            f"   <i>{tx_time} | Balance: ${tx['balance_after']:.2f}</i>\n\n"
        )

    # Add navigation buttons
    keyboard = [[
        InlineKeyboardButton("üí∞ Current Balance",
                             callback_data="show_balance"),
        InlineKeyboardButton("üîô Back", callback_data="show_balance")
    ]]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text(
        history_text,
        parse_mode='HTML',
        reply_markup=reply_markup
    )


async def handle_approve_deposit(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle deposit approval by admin"""
    query = update.callback_query
    if not query or not query.from_user or not query.data:
        return

    # Extract deposit ID from callback data: "approve_deposit_DEP_123456789_1754854768"
    # Get "DEP_123456789_1754854768"
    deposit_id = "_".join(query.data.split('_')[2:])
    admin_id = query.from_user.id

    if not is_admin(admin_id):
        await query.answer("‚ùå Access denied.")
        return

    await query.answer()

    if not wallet_system:
        await query.edit_message_text("‚ùå Wallet system not available.")
        return

    # Approve the deposit
    success = wallet_system.approve_deposit(deposit_id, admin_id)

    if success:
        deposit = wallet_system.get_deposit_status(deposit_id)
        if not deposit:
            await query.edit_message_text("‚ùå Deposit not found.")
            return

        user_id = deposit['user_id']
        amount = deposit['amount_usd']

        # Admin notification
        await query.edit_message_text(
            f"‚úÖ <b>Deposit Approved</b>\n\n"
            f"Deposit {deposit_id} has been approved.\n"
            f"User {user_id} wallet credited with ${amount:.2f}.",
            parse_mode='HTML'
        )

        # Notify user
        try:
            new_balance = wallet_system.get_user_balance(user_id)

            keyboard = [[
                InlineKeyboardButton("üì± Browse Services",
                                     callback_data="browse_services"),
                InlineKeyboardButton(
                    "üí∞ Check Balance", callback_data="show_balance")
            ]]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await context.bot.send_message(
                chat_id=user_id,
                text=(
                    f"‚úÖ <b>Deposit Approved!</b>\n\n"
                    f"üí∞ <b>Amount:</b> ${amount:.2f}\n"
                    f"üí≥ <b>New Balance:</b> ${new_balance:.2f}\n\n"
                    f"üéâ Your wallet has been credited!\n"
                    f"You can now purchase SMS services instantly."
                ),
                parse_mode='HTML',
                reply_markup=reply_markup
            )
        except RuntimeError as notify_error:
            logger.error("Failed to notify user %s: %s", user_id, notify_error)

        logger.info("‚úÖ Deposit %s approved by admin %s", deposit_id, admin_id)

    else:
        await query.edit_message_text(
            f"‚ùå <b>Approval Failed</b>\n\n"
            f"Could not approve deposit {deposit_id}.\n"
            f"Deposit may have expired or already been processed.",
            parse_mode='HTML'
        )


async def handle_deny_deposit(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle deposit denial by admin"""
    query = update.callback_query
    if not query or not query.from_user or not query.data:
        return

    # Extract deposit ID from callback data: "deny_deposit_DEP_123456789_1754854768"
    # Get "DEP_123456789_1754854768"
    deposit_id = "_".join(query.data.split('_')[2:])
    admin_id = query.from_user.id

    if not is_admin(admin_id):
        await query.answer("‚ùå Access denied.")
        return

    await query.answer()

    if not wallet_system:
        await query.edit_message_text("‚ùå Wallet system not available.")
        return

    deposit = wallet_system.get_deposit_status(deposit_id)
    if deposit:
        user_id = deposit['user_id']
        amount = deposit['amount_usd']

        # Update deposit status to denied
        if wallet_system and hasattr(wallet_system, 'deposits_table') and wallet_system.deposits_table:
            Deposit = Query()
            wallet_system.deposits_table.update({
                'status': 'denied',
                'admin_denied_at': datetime.now().isoformat(),
                'admin_denied_by': str(admin_id)
            }, Deposit.deposit_id == deposit_id)
        else:
            logger.warning(
                "‚ö†Ô∏è Cannot update deposit status - deposits_table not available")

        # Admin notification
        await query.edit_message_text(
            f"‚ùå <b>Deposit Denied</b>\n\n"
            f"Deposit {deposit_id} has been denied.\n"
            f"User {user_id} has been notified.",
            parse_mode='HTML'
        )

        # Notify user
        try:
            await context.bot.send_message(
                chat_id=user_id,
                text=(
                    f"‚ùå <b>Deposit Denied</b>\n\n"
                    f"üí∞ <b>Amount:</b> ${amount:.2f}\n"
                    f"üÜî <b>Deposit ID:</b> <code>{deposit_id}</code>\n\n"
                    f"Your deposit was not approved. Please ensure:\n"
                    f"‚Ä¢ Exact amount was sent\n"
                    f"‚Ä¢ Payment was sent to correct wallet\n"
                    f"‚Ä¢ Transaction screenshot is clear\n\n"
                    f"Contact admin if you believe this is an error."
                ),
                parse_mode='HTML'
            )
        except RuntimeError as notify_error:
            logger.error("Failed to notify user %s: %s", user_id, notify_error)

        logger.info("‚ùå Deposit %s denied by admin %s", deposit_id, admin_id)

    else:
        await query.edit_message_text("‚ùå Deposit not found.")


# =============================================================================
# CALLBACK QUERY HANDLERS
# =============================================================================


async def handle_browse_services(update: Update, _context: ContextTypes.DEFAULT_TYPE):
    """Handle service browsing - show available services with pricing"""
    if not update.callback_query:
        return

    query = update.callback_query
    await query.answer()

    # Show loading message
    await query.edit_message_text(
        "üîÑ <b>Loading Available Services...</b>\n\n"
        "Checking real-time pricing and availability...",
        parse_mode='HTML'
    )

    try:
        if not sms_api:
            await query.edit_message_text(
                "‚ùå SMS API not initialized. Please contact administrator."
            )
            return

        # Get available services with pricing
        services_info = await sms_api.get_available_services_for_purchase()

        if not services_info.get('success') or not services_info.get('services'):
            keyboard = [
                [InlineKeyboardButton(
                    "üîÑ Refresh Services", callback_data="browse_services")],
                [InlineKeyboardButton(
                    "üîô Back to Menu", callback_data="back_to_start")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await query.edit_message_text(
                "‚ùå <b>No Services Available</b>\n\n"
                "All SMS services are currently unavailable. This could be due to:\n"
                "‚Ä¢ High demand for phone numbers\n"
                "‚Ä¢ Temporary API maintenance\n"
                "‚Ä¢ Network connectivity issues\n\n"
                "‚è∞ <i>Please try refreshing in a few moments.</i>",
                parse_mode='HTML',
                reply_markup=reply_markup
            )
            return

        # Build service selection menu
        services = services_info['services']
        message_text = "üìã <b>Available SMS Services</b> üì±\n\n"
        message_text += f"‚úÖ <i>{len(services)} services currently available</i>\n"
        message_text += f"üí∞ <i>Profit margin: {services_info.get('profit_margin', 25)}%</i>\n\n"

        keyboard = []
        for service in services:
            service_name = service['name']
            selling_price = service['selling_price']
            api_price = service['api_price']
            profit = service['profit']

            # Add service info to message
            status_icon = "‚≠ê" if service['recommended'] else "üì±"
            message_text += f"{status_icon} <b>{service_name}</b>\n"
            message_text += f"   ÔøΩ Price: ${selling_price:.2f}\n"
            message_text += f"   üìä Cost: ${api_price:.2f} | Profit: ${profit:.2f}\n"
            if service['recommended']:
                message_text += "   üéØ <i>Recommended service</i>\n"
            message_text += "\n"

            # Add button for service with availability confirmation
            button_text = f"‚úÖ {service_name} - ${selling_price:.2f}"
            if service['recommended']:
                button_text = f"‚≠ê {service_name} - ${selling_price:.2f}"

            callback_data = f"select_service_{service['id']}_{selling_price}"
            keyboard.append([InlineKeyboardButton(
                button_text, callback_data=callback_data)])

        message_text += "üìã <b>Selection Guide:</b>\n"
        message_text += "‚Ä¢ ‚≠ê = Recommended for best compatibility\n"
        message_text += "‚Ä¢ All prices are live and availability is confirmed\n"
        message_text += "‚Ä¢ Payment required before SMS number purchase\n"
        message_text += "‚Ä¢ Admin approval needed for processing\n\n"
        message_text += "‚ö° <i>Choose a service to continue with payment</i>"

        # Add refresh and back buttons
        keyboard.append([
            InlineKeyboardButton("üîÑ Refresh Availability",
                                 callback_data="browse_services"),
            InlineKeyboardButton(
                "üîô Back to Menu", callback_data="back_to_start")
        ])

        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.edit_message_text(
            message_text,
            parse_mode='HTML',
            reply_markup=reply_markup
        )

        # Log service display for monitoring
        logger.info(
            "‚úÖ Displayed %d available services to user %s", len(services), query.from_user.id)

    except RuntimeError as e:
        logger.error("‚ùå Error browsing services: %s", str(e))
        keyboard = [
            [InlineKeyboardButton(
                "üîÑ Try Again", callback_data="browse_services")],
            [InlineKeyboardButton(
                "üîô Back to Menu", callback_data="back_to_start")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.edit_message_text(
            f"‚ùå <b>Error Loading Services</b>\n\n"
            f"An error occurred while loading services:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Please try again or contact support if the issue persists.",
            parse_mode='HTML',
            reply_markup=reply_markup
        )


async def handle_service_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle specific service selection"""
    if not update.callback_query:
        return

    query = update.callback_query
    await query.answer()

    # Extract service info from callback data
    try:
        callback_data = query.data
        if not callback_data:
            logger.error("‚ùå No callback data received")
            return

        parts = callback_data.split('_')
        service_id = int(parts[2])
        selling_price = float(parts[3])

        # Store selection in user context
        if context.user_data is not None:
            context.user_data['selected_service_id'] = service_id
            context.user_data['selected_price'] = selling_price

        # Get service name
        service_names = {1574: 'Ring4', 22: 'Telegram',
                         395: 'Google', 1012: 'WhatsApp'}
        service_name = service_names.get(service_id, f'Service {service_id}')

        # Proceed with payment workflow
        await handle_service_purchase(update, context, service_id, service_name, selling_price)

    except RuntimeError as e:
        logger.error("‚ùå Error in service selection: %s", str(e))
        await query.edit_message_text(
            "‚ùå Error processing selection. Please try again.",
            parse_mode='HTML'
        )


async def handle_service_purchase(update: Update, context: ContextTypes.DEFAULT_TYPE, service_id: int, service_name: str, selling_price: float):
    """Optimized purchase flow with real-time availability checking"""
    query = update.callback_query
    user = update.effective_user

    if not query or not user:
        logger.error("‚ùå Missing query or user in service purchase")
        return

    user_logger.info(
        "üõí User %s (@%s) initiating %s purchase - $%.2f", user.id, user.username, service_name, selling_price)
    performance_logger.info(
        "‚è±Ô∏è Starting purchase flow for service %s", service_id)

    # Step 1: Immediate availability check with optimized async
    await query.edit_message_text(
        f"üîç <b>Checking {service_name} Availability...</b>\n\n"
        f"üí∞ <b>Price:</b> ${selling_price}\n"
        f"üì± <b>Service:</b> {service_name}\n\n"
        "‚è≥ Real-time availability check in progress...",
        parse_mode='HTML'
    )

    if not sms_api:
        logger.error("‚ùå SMS API not initialized - critical system error")
        await query.edit_message_text("‚ùå SMS API not initialized.")
        return

    # Optimized concurrent availability and balance checks
    try:
        performance_logger.debug(
            "üîç Starting concurrent availability checks for %s", service_name)

        # Run availability check and balance check concurrently for speed
        # Default to country_id=1 (USA) for availability check
        availability_task = asyncio.create_task(
            sms_api.check_service_availability(service_id, 1)
        )
        balance_task = asyncio.create_task(sms_api.check_balance())

        # Wait for both checks to complete
        availability_result, balance_result = await asyncio.gather(
            availability_task, balance_task, return_exceptions=True
        )

        performance_logger.info(
            "‚ö° Concurrent checks completed for %s", service_name)

        # Process availability result
        if isinstance(availability_result, Exception):
            logger.error("‚ùå Availability check failed: %s",
                         str(availability_result))
            await query.edit_message_text(
                f"‚ùå <b>Service Check Failed</b>\n\n"
                f"Unable to verify {service_name} availability.\n"
                f"Please try again later.",
                parse_mode='HTML'
            )
            return

        # At this point, availability_result is a dict, not an exception
        if not isinstance(availability_result, dict) or not availability_result.get('available', False):
            error_msg = availability_result.get(
                'message', f'{service_name} service temporarily unavailable') if isinstance(availability_result, dict) else f'{service_name} service temporarily unavailable'
            user_logger.warning(
                "‚ö†Ô∏è %s unavailable for user %s: %s", service_name, user.id, error_msg)

            await query.edit_message_text(
                f"‚ùå <b>{service_name} Unavailable</b>\n\n"
                f"üí∞ <b>Price:</b> ${selling_price}\n"
                f"üì± <b>Service:</b> {service_name}\n\n"
                f"‚ö†Ô∏è <b>Issue:</b> {error_msg}\n\n"
                "üí° <b>Tip:</b> Try another service or check back in a few minutes.",
                parse_mode='HTML',
                reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton(
                        "üîô Back to Services", callback_data="browse_services")
                ]])
            )
            return

        # Process balance result (if not exception)
        if not isinstance(balance_result, Exception) and isinstance(balance_result, dict) and balance_result.get('success'):
            current_balance = float(balance_result.get('balance', '0.0'))
            api_logger.debug("üí∞ Current API balance: $%.2f", current_balance)

            # Estimate required balance (API price + buffer)
            estimated_api_cost = selling_price * 0.8  # Rough estimate
            if current_balance < estimated_api_cost:
                api_logger.warning(
                    "‚ö†Ô∏è Low API balance: $%.2f < $%.2f", current_balance, estimated_api_cost)

    except RuntimeError as e:
        logger.error(
            "‚ùå Error during availability checks for %s: %s", service_name, str(e))
        performance_logger.error(
            "‚ö†Ô∏è Availability check failed for service %s: %s", service_id, e)
        await query.edit_message_text(
            f"‚ùå <b>Service Check Failed</b>\n\n"
            f"Unable to verify {service_name} availability.\n"
            "üîß <b>Error:</b> {str(e)[:100]}...\n\n"
            "Please try again in a moment.",
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("üîô Back to Services",
                                     callback_data="browse_services")
            ]])
        )
        return

    # Step 2: Service confirmed available - proceed with wallet-based purchase
    user_logger.info(
        "‚úÖ %s confirmed available for user %s", service_name, user.id)

    # Get user's wallet balance
    user_balance = wallet_system.get_user_balance(
        user.id) if wallet_system else 0.00

    await query.edit_message_text(
        f"‚úÖ <b>{service_name} Available!</b>\n\n"
        f"üí∞ <b>Service Price:</b> ${selling_price}\n"
        f"ÔøΩ <b>Your Balance:</b> ${user_balance:.2f}\n"
        f"üì± <b>Service:</b> {service_name}\n\n"
        "‚ö° Checking wallet balance...",
        parse_mode='HTML'
    )

    # Step 3: Wallet-based purchase check
    if not wallet_system:
        await query.edit_message_text(
            "‚ùå <b>Wallet System Unavailable</b>\n\n"
            "Please contact administrator.",
            parse_mode='HTML'
        )
        return

    # Check if user has sufficient balance
    if not wallet_system.has_sufficient_balance(user.id, selling_price):
        needed_amount = selling_price - user_balance
        keyboard = [[
            InlineKeyboardButton("üí∞ Add Funds", callback_data="deposit_funds"),
            InlineKeyboardButton("üîô Back", callback_data="start")
        ]]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.edit_message_text(
            f"üí≥ <b>Insufficient Balance</b>\n\n"
            f"üí∞ <b>Service Cost:</b> ${selling_price:.2f}\n"
            f"üí≥ <b>Your Balance:</b> ${user_balance:.2f}\n"
            f"üí∏ <b>Need:</b> ${needed_amount:.2f} more\n\n"
            f"üí° Add funds to your wallet to continue.\n"
            f"Minimum deposit: ${wallet_system.MIN_DEPOSIT_USD}",
            parse_mode='HTML',
            reply_markup=reply_markup
        )
        return

    # User has sufficient balance - proceed with instant purchase
    user_logger.info(
        "‚ö° Instant purchase: User %s has sufficient balance ($%.2f)", user.id, user_balance)

    # Store service info for purchase
    if context.user_data is not None:
        context.user_data['selected_service_id'] = service_id
        context.user_data['selected_service_name'] = service_name
        context.user_data['selected_price'] = selling_price

    # Show confirmation
    keyboard = [[
        InlineKeyboardButton(
            "‚úÖ Confirm Purchase", callback_data=f"wallet_purchase_{service_id}_{selling_price}"),
        InlineKeyboardButton("‚ùå Cancel", callback_data="start")
    ]]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text(
        f"üí≥ <b>Confirm Purchase</b>\n\n"
        f"ÔøΩ <b>Service:</b> {service_name}\n"
        f"üí∞ <b>Cost:</b> ${selling_price:.2f}\n"
        f"ÔøΩ <b>Your Balance:</b> ${user_balance:.2f}\n"
        f"ÔøΩ <b>After Purchase:</b> ${user_balance - selling_price:.2f}\n\n"
        f"‚ö° <b>Instant purchase using wallet balance</b>\n"
        f"üîÑ Service will be delivered immediately",
        parse_mode='HTML',
        reply_markup=reply_markup
    )

    if user:
        logger.info(
            "üí∞ Wallet purchase confirmation shown to user %s for %s: $%.2f", user.id, service_name, selling_price)
    else:
        logger.info(
            "üí∞ Wallet purchase confirmation shown for %s: $%.2f", service_name, selling_price)


# =============================================================================
# ORIGINAL CALLBACK QUERY HANDLERS
# =============================================================================


async def handle_buy_ring4(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle Ring4 purchase - now routes to service-specific flow"""
    if not update.effective_user:
        return

    user = update.effective_user

    # Check if this is a callback query or direct command
    if update.callback_query:
        query = update.callback_query
        await query.answer()  # Acknowledge callback immediately

        logger.info("üéØ Ring4 purchase request from user %s",
                    user.id if user else 'Unknown')

        # Route to the new service selection flow with Ring4 pre-selected
        # This ensures users get Ring4 specifically, not a fallback service
        await handle_service_purchase(update, context, 1574, "Ring4", 0.17)
    else:
        if not update.message:
            return
        # For direct messages, redirect to start menu with service selection
        await start_command(update, context)


async def handle_auto_purchase(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle auto-purchase callback from payment approval notification"""
    query = update.callback_query
    user = update.effective_user

    if not query or not user:
        return

    await query.answer()

    try:
        # Parse callback data: "auto_purchase_{service_id}_{service_name}_{selling_price}"
        if not query.data:
            await query.edit_message_text("‚ùå Invalid purchase data.")
            return

        parts = query.data.split('_', 3)
        if len(parts) < 4:
            await query.edit_message_text("‚ùå Invalid purchase data.")
            return

        service_id = int(parts[2])
        # Split from the right to get price
        service_data = parts[3].rsplit('_', 1)
        service_name = service_data[0]
        selling_price = float(service_data[1])

        # Store in context
        if context.user_data is not None:
            context.user_data['selected_service_id'] = service_id
            context.user_data['selected_service_name'] = service_name
            context.user_data['selected_price'] = selling_price

        user_logger.info(
            "üöÄ Auto-purchase initiated by user %s: %s ($%.2f)", user.id if user else 'Unknown', service_name, selling_price)

        # Execute the purchase
        await process_wallet_service_purchase(
            user.id if user else 0, context, query.edit_message_text, service_id, service_name
        )

    except RuntimeError as e:
        logger.error("Auto-purchase failed for user %s: %s",
                     user.id if user else 'Unknown', e)
        await query.edit_message_text(
            f"‚ùå <b>Auto-Purchase Failed</b>\n\n"
            f"Error: {str(e)[:100]}...\n\n"
            f"Please use /buy to browse services manually.",
            parse_mode='HTML'
        )


async def handle_service_unavailable(user_id: int, payment_id: Optional[str], context: ContextTypes.DEFAULT_TYPE, send_method, reason: str):
    """Handle cases where service cannot be provided and initiate refund"""

    logger.error("üö´ Service unavailable for user %s: %s", user_id, reason)

    # Notify user about service issue and automatic refund
    await send_method(
        f"‚ùå <b>Service Temporarily Unavailable</b>\n\n"
        f"üîß <b>Issue:</b> {reason}\n"
        f"üí∞ <b>Refund:</b> Processing automatic refund\n"
        f"‚è∞ <b>Timeline:</b> 1-2 business days\n\n"
        f"üéØ We'll notify you when the service is restored.\n"
        f"üí¨ Contact admin if you need immediate assistance.\n\n"
        f"üÜî <b>Payment ID:</b> <code>{payment_id or 'N/A'}</code>",
        parse_mode='HTML'
    )

    # Notify all admins about service issue
    admin_message = (
        f"üö´ <b>SERVICE UNAVAILABLE ALERT</b>\n\n"
        f"üë§ <b>User:</b> {user_id}\n"
        f"üí≥ <b>Payment ID:</b> <code>{payment_id or 'N/A'}</code>\n"
        f"‚ö†Ô∏è <b>Issue:</b> {reason}\n\n"
        f"üîß <b>Action Required:</b>\n"
        f"‚Ä¢ Check SMSPool balance\n"
        f"‚Ä¢ Top up account if needed\n"
        f"‚Ä¢ Monitor service status\n"
        f"‚Ä¢ Process refund if needed\n\n"
        f"üéØ Service quality is compromised!"
    )

    for admin_id in ADMIN_IDS:
        try:
            await context.bot.send_message(
                chat_id=admin_id,
                text=admin_message,
                parse_mode='HTML'
            )
        except RuntimeError as e:
            logger.error("Failed to notify admin %s: %s", admin_id, str(e))

    # If we have a wallet system, handle refund
    if wallet_system:
        try:
            logger.info(
                "üí∞ Auto-refund initiated due to service unavailability")
        except RuntimeError as e:
            logger.error(
                "Error handling service unavailable refund: %s", str(e))


# Legacy payment function removed - now using wallet-based purchasing


async def process_wallet_service_purchase(user_id: int, context: ContextTypes.DEFAULT_TYPE, send_method, service_id: int, service_name: str):
    """Process service purchase using wallet balance"""

    # Get the selected price from user data
    selling_price = context.user_data.get(
        'selected_price', 0.15) if context.user_data else 0.15

    purchase_logger.info(
        "üöÄ Starting wallet purchase for user %s: %s ($%.2f)", user_id, service_name, selling_price)

    start_time = asyncio.get_event_loop().time()
    order_id = None

    try:
        # Step 1: Deduct from wallet balance first
        if not wallet_system:
            await send_method("‚ùå Wallet system unavailable. Contact administrator.", parse_mode='HTML')
            return

        # Attempt to deduct balance
        order_id = f"ORD_{user_id}_{int(datetime.now().timestamp())}"
        deduction_success = wallet_system.process_service_purchase(
            user_id=user_id,
            service_price=selling_price,
            service_name=service_name,
            order_id=order_id
        )

        if not deduction_success:
            user_balance = wallet_system.get_user_balance(user_id)
            await send_method(
                f"‚ùå <b>Insufficient Balance</b>\n\n"
                f"üí∞ Service Cost: ${selling_price:.2f}\n"
                f"üí≥ Your Balance: ${user_balance:.2f}\n"
                f"üí∏ Need: ${selling_price - user_balance:.2f} more\n\n"
                f"Please add funds to your wallet.",
                parse_mode='HTML'
            )
            return

        purchase_logger.info(
            "‚úÖ Wallet balance deducted for user %s: $%.2f", user_id, selling_price)

        # Step 2: Show processing message
        await send_method(
            f"‚ö° <b>Processing {service_name} Purchase</b>\n\n"
            f"üí∞ Cost: ${selling_price:.2f} (deducted from wallet)\n"
            f"üì± Service: {service_name}\n"
            f"üîÑ Acquiring your number...",
            parse_mode='HTML'
        )

        if not sms_api:
            # Refund to wallet and show error
            wallet_system.process_refund(
                user_id, selling_price, order_id, "SMS API unavailable")
            await send_method("‚ùå SMS service unavailable. Amount refunded to wallet.", parse_mode='HTML')
            return

        # Step 3: Validate API balance
        try:
            balance_result = await sms_api.check_balance()
        except (AttributeError, RuntimeError):
            # Refund to wallet
            wallet_system.process_refund(
                user_id, selling_price, order_id, "Provider balance check failed")
            await send_method("‚ùå Service provider unavailable. Amount refunded to wallet.", parse_mode='HTML')
            return

        if isinstance(balance_result, Exception) or not balance_result.get('success'):
            # Refund to wallet
            wallet_system.process_refund(
                user_id, selling_price, order_id, "Provider balance check failed")
            await send_method("‚ùå Service provider unavailable. Amount refunded to wallet.", parse_mode='HTML')
            return

        current_balance = float(balance_result.get('balance', '0.0'))
        estimated_cost = selling_price * 0.8  # 80% safety margin

        if current_balance < estimated_cost:
            # Refund to wallet
            wallet_system.process_refund(
                user_id, selling_price, order_id, "Provider insufficient balance")
            await send_method(
                f"‚ùå Service temporarily unavailable (provider balance: ${current_balance:.2f}). "
                f"Amount refunded to wallet.",
                parse_mode='HTML'
            )
            return

        # Step 4: Purchase the service
        purchase_logger.info(
            "üõí Executing %s purchase for user %s", service_name, user_id)

        await send_method(
            f"üîÑ <b>Acquiring {service_name} Number...</b>\n\n"
            f"üí∞ Payment: ${selling_price:.2f} (processed)\n"
            f"üìû Requesting number from provider...\n"
            f"‚è±Ô∏è This may take a few seconds...",
            parse_mode='HTML'
        )

        # Execute the purchase based on service type
        if service_id == RING4_SERVICE_ID:
            result = await sms_api.purchase_ring4_number()
        else:
            result = await sms_api.purchase_specific_service(service_id, service_name)

        # Step 5: Process purchase result
        if result['success']:
            purchase_logger.info(
                "‚úÖ %s number acquired successfully for user %s", service_name, user_id)

            # Create order record
            order_data = {
                'user_id': user_id,
                'service_id': service_id,
                'service_name': service_name,
                'number': result['number'],
                'order_id': result.get('order_id', order_id),
                'cost': selling_price,
                'status': 'pending',
                'created_at': datetime.now().isoformat(),
                'expires_at': (datetime.now() + timedelta(seconds=ORDER_EXPIRES_IN)).isoformat()
            }

            db_order_id = db.create_order(user_id, order_data)

            # Update with actual order ID
            if 'order_id' in result:
                order_id = result['order_id']
                db.update_order_status(db_order_id, 'pending')

            # Create cancel/refund buttons for the order
            keyboard = [
                [
                    InlineKeyboardButton(
                        "üö´ Cancel Order", callback_data=f"cancel_order_{order_id}"),
                    InlineKeyboardButton(
                        "üí∞ Request Refund", callback_data=f"refund_{order_id}")
                ],
                [
                    InlineKeyboardButton(
                        "üì± Check Balance", callback_data="show_balance"),
                    InlineKeyboardButton(
                        "üè† Main Menu", callback_data="back_to_start")
                ]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            # Success message with action buttons
            await send_method(
                f"‚úÖ <b>{service_name} Number Acquired!</b>\n\n"
                f"üì± <b>Your Number:</b> <code>{result['number']}</code>\n"
                f"üí∞ <b>Cost:</b> ${selling_price:.2f}\n"
                f"üÜî <b>Order ID:</b> <code>{order_id}</code>\n"
                f"‚è∞ <b>Valid for:</b> 10 minutes\n\n"
                f"üîî <b>Waiting for SMS...</b>\n"
                f"OTP will be delivered automatically when received.\n\n"
                f"üí° <b>Need help?</b> Use the buttons below for order management.",
                parse_mode='HTML',
                reply_markup=reply_markup
            )

            # Start OTP polling
            start_otp_polling(order_id, user_id, context)

            user_balance_after = wallet_system.get_user_balance(user_id)
            purchase_logger.info(
                "üéâ Purchase completed for user %s: %s | Order: %s | Balance: $%.2f",
                user_id, service_name, order_id, user_balance_after
            )

        else:
            # Purchase failed - refund to wallet
            error_msg = result.get('message', 'Unknown error')
            purchase_logger.error(
                "‚ùå %s purchase failed for user %s: %s", service_name, user_id, error_msg)

            # Process refund
            refund_success = wallet_system.process_refund(
                user_id, selling_price, order_id, f"Purchase failed: {error_msg}")

            refund_text = " Amount refunded to wallet." if refund_success else " Please contact support for refund."

            await send_method(
                f"‚ùå <b>Purchase Failed</b>\n\n"
                f"Service: {service_name}\n"
                f"Error: {error_msg}\n"
                f"üí∞ ${selling_price:.2f}{refund_text}",
                parse_mode='HTML'
            )

    except RuntimeError as e:
        purchase_logger.error(
            "‚ùå Critical error in wallet purchase for user %s: %s", user_id, str(e))

        # Attempt refund on any error
        if order_id and wallet_system:
            try:
                wallet_system.process_refund(
                    user_id, selling_price, order_id, f"System error: {str(e)}")
                refund_text = " Amount refunded to wallet."
            except OSError:
                refund_text = " Please contact support for refund."
        else:
            refund_text = ""

        await send_method(
            f"‚ùå <b>System Error</b>\n\n"
            f"An error occurred during purchase.{refund_text}\n"
            f"Please try again or contact support.",
            parse_mode='HTML'
        )

    finally:
        end_time = asyncio.get_event_loop().time()
        performance_logger.info(
            "‚è±Ô∏è Purchase processing completed in %.2fs", end_time - start_time)


# =============================================================================
# OTP & ORDER STATUS HANDLERS
# =============================================================================
# OTP & ORDER STATUS HANDLERS
# =============================================================================


async def handle_refund_request(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle refund request"""
    query = update.callback_query
    if not query or not query.from_user:
        return

    user_id = query.from_user.id

    await query.answer()

    try:
        if not query.data:
            await query.edit_message_text("‚ùå Invalid request data.")
            return

        # Extract order_id from callback data (format: "refund_{order_id}")
        # Keep as string, don't convert to int
        order_id = query.data.split('_', 1)[1]

        # Verify order belongs to user and is refundable
        order = db.get_order(order_id)
        if not order or order['user_id'] != user_id:
            await query.edit_message_text("‚ùå Order not found or access denied.")
            return

        if order['status'] not in ['pending', 'timeout', 'error']:
            await query.edit_message_text(
                f"‚ùå Order #{order_id} is not eligible for refund.\n"
                f"Current status: {order['status']}"
            )
            return

        # Create refund request
        db.create_refund_request(user_id, order_id)

        # Notify all admins
        for admin_id in ADMIN_IDS:
            try:
                keyboard = [[
                    InlineKeyboardButton(
                        "‚úÖ Approve", callback_data=f"approve_refund_{order_id}"),
                    InlineKeyboardButton(
                        "‚ùå Deny", callback_data=f"deny_refund_{order_id}")
                ]]
                reply_markup = InlineKeyboardMarkup(keyboard)

                await context.bot.send_message(
                    chat_id=admin_id,
                    text=(
                        f"üí∞ <b>Refund Request</b>\n\n"
                        f"üë§ User: {user_id}\n"
                        f"üì± Order: #{order_id}\n"
                        f"üí∞ Amount: ${order['cost']}\n"
                        f"üìû Number: {order['number']}\n"
                        f"üîÑ Status: {order['status']}\n\n"
                        f"Approve or deny this refund request:"
                    ),
                    parse_mode='HTML',
                    reply_markup=reply_markup
                )
            except RuntimeError as e:
                logger.error("Failed to notify admin %s: %s", admin_id, str(e))

        await query.edit_message_text(
            f"‚úÖ <b>Refund Requested</b>\n\n"
            f"Your refund request for order #{order_id} has been submitted.\n"
            f"Administrators have been notified.\n\n"
            f"You will be notified when the request is processed.",
            parse_mode='HTML'
        )

        logger.info(
            "üí∞ Refund requested by user %s for order %s", user_id, order_id)

    except RuntimeError as e:
        logger.error("Error processing refund request: %s", str(e))
        await query.edit_message_text("‚ùå Error processing refund request.")


async def show_admin_refunds(update: Update, _context: ContextTypes.DEFAULT_TYPE):
    """Show pending refunds to admin"""
    if not update.effective_user:
        return

    user_id = update.effective_user.id

    if not is_admin(user_id):
        if update.callback_query:
            await update.callback_query.answer("‚ùå Access denied.")
        return

    pending_refunds = db.get_pending_refunds()

    if not pending_refunds:
        text = "üí∞ <b>No Pending Refunds</b>\n\nAll refund requests have been processed."
        if update.callback_query:
            await update.callback_query.edit_message_text(text, parse_mode='HTML')
        elif update.message:
            await update.message.reply_text(text, parse_mode='HTML')
        return

    keyboard = []
    for refund in pending_refunds:
        order = db.get_order(refund['order_id'])
        if order:
            keyboard.append([
                InlineKeyboardButton(
                    f"Order #{refund['order_id']} - ${order['cost']}",
                    callback_data=f"refund_details_{refund['order_id']}"
                )
            ])

    reply_markup = InlineKeyboardMarkup(keyboard)

    text = (
        f"üí∞ <b>Pending Refunds ({len(pending_refunds)})</b>\n\n"
        f"Select a refund to process:"
    )

    if update.callback_query:
        await update.callback_query.edit_message_text(text, parse_mode='HTML', reply_markup=reply_markup)
    elif update.message:
        await update.message.reply_text(text, parse_mode='HTML', reply_markup=reply_markup)


async def handle_refund_details(update: Update, _context: ContextTypes.DEFAULT_TYPE):
    """Show refund details to admin"""
    query = update.callback_query
    if not query or not query.from_user:
        return

    user_id = query.from_user.id

    if not is_admin(user_id):
        await query.answer("‚ùå Access denied.")
        return

    await query.answer()

    try:
        if not query.data:
            await query.edit_message_text("‚ùå Invalid request data.")
            return

        # Keep as string, don't convert to int
        # Join everything after 'refund_details_'
        order_id = '_'.join(query.data.split('_')[2:])
        order = db.get_order(order_id)

        if not order:
            await query.edit_message_text("‚ùå Order not found.")
            return

        keyboard = [[
            InlineKeyboardButton("‚úÖ Approve Refund",
                                 callback_data=f"approve_refund_{order_id}"),
            InlineKeyboardButton(
                "‚ùå Deny Refund", callback_data=f"deny_refund_{order_id}")
        ], [
            InlineKeyboardButton("‚Üê Back to Refunds",
                                 callback_data="admin_refunds")
        ]]
        reply_markup = InlineKeyboardMarkup(keyboard)

        created = datetime.fromisoformat(
            order['created_at']).strftime('%Y-%m-%d %H:%M:%S')

        details_text = (
            f"üí∞ <b>Refund Request Details</b>\n\n"
            f"üì± <b>Order:</b> #{order_id}\n"
            f"üë§ <b>User:</b> {order['user_id']}\n"
            f"üìû <b>Number:</b> {order['number']}\n"
            f"üí∞ <b>Cost:</b> ${order['cost']}\n"
            f"üîÑ <b>Status:</b> {order['status']}\n"
            f"üìÖ <b>Created:</b> {created}\n\n"
            f"Choose an action:"
        )

        await query.edit_message_text(
            details_text,
            parse_mode='HTML',
            reply_markup=reply_markup
        )

    except RuntimeError as e:
        logger.error("Error showing refund details: %s", str(e))
        await query.edit_message_text("‚ùå Error loading refund details.")


async def process_refund_approval(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Process refund approval/denial"""
    query = update.callback_query
    if not query or not query.from_user:
        return

    user_id = query.from_user.id

    if not is_admin(user_id):
        await query.answer("‚ùå Access denied.")
        return

    await query.answer()

    try:
        if not query.data:
            await query.edit_message_text("‚ùå Invalid request data.")
            return

        action, order_id = query.data.split('_')[0], '_'.join(
            query.data.split('_')[2:])  # Keep order_id as string
        order = db.get_order(order_id)

        if not order:
            await query.edit_message_text("‚ùå Order not found.")
            return

        if action == "approve":
            # Process wallet refund first
            if wallet_system:
                refund_success = wallet_system.process_refund(
                    user_id=order['user_id'],
                    refund_amount=order['cost'],
                    order_id=order_id,
                    reason="Admin approved refund"
                )

                if not refund_success:
                    await query.edit_message_text(
                        f"‚ùå <b>Wallet Refund Failed</b>\n\n"
                        f"Failed to process wallet refund for order #{order_id}.\n"
                        f"Please try again or contact system administrator.",
                        parse_mode='HTML'
                    )
                    return

            # Cancel order with SMSPool if sms_api is available
            if sms_api:
                cancel_result = await sms_api.cancel_order(str(order_id))

                if cancel_result.get('success'):
                    # Update order and refund status
                    db.update_order_status(order_id, 'refunded')
                    db.update_refund_status(order_id, 'approved', user_id)

                    # Notify user with wallet balance update
                    try:
                        user_balance = wallet_system.get_user_balance(
                            order['user_id']) if wallet_system else 0
                        await context.bot.send_message(
                            chat_id=order['user_id'],
                            text=(
                                f"‚úÖ <b>Refund Approved & Processed</b>\n\n"
                                f"Order: #{order_id}\n"
                                f"üí∞ Refund Amount: ${order['cost']}\n"
                                f"üìû Number: {order['number']}\n"
                                f"üí≥ New Balance: ${user_balance:.2f}\n\n"
                                f"‚úÖ Order cancelled with provider\n"
                                f"‚úÖ Amount refunded to your wallet"
                            ),
                            parse_mode='HTML'
                        )
                    except RuntimeError as e:
                        logger.error(
                            "Failed to notify user %s: %s", order['user_id'], str(e))

                    await query.edit_message_text(
                        f"‚úÖ <b>Refund Approved & Processed</b>\n\n"
                        f"Order #{order_id} refund completed:\n"
                        f"üí∞ ${order['cost']} refunded to wallet\n"
                        f"üìû Order cancelled with provider\n"
                        f"üë§ User {order['user_id']} notified",
                        parse_mode='HTML'
                    )

                    logger.info(
                        "‚úÖ Refund approved and wallet credited by admin %s for order %s", user_id, order_id)
                else:
                    await query.edit_message_text(
                        f"‚ö†Ô∏è <b>Partial Refund Success</b>\n\n"
                        f"üí∞ Wallet refunded: ${order['cost']}\n"
                        f"‚ùå Provider cancellation failed: {cancel_result.get('message', 'Unknown error')}\n\n"
                        f"User has been refunded to wallet.",
                        parse_mode='HTML'
                    )
            else:
                # SMS API not available, but still approve the refund with wallet
                db.update_order_status(order_id, 'refunded')
                db.update_refund_status(order_id, 'approved', user_id)

                # Notify user about wallet refund
                try:
                    user_balance = wallet_system.get_user_balance(
                        order['user_id']) if wallet_system else 0
                    await context.bot.send_message(
                        chat_id=order['user_id'],
                        text=(
                            f"‚úÖ <b>Refund Approved & Processed</b>\n\n"
                            f"Order: #{order_id}\n"
                            f"üí∞ Refund Amount: ${order['cost']}\n"
                            f"üìû Number: {order['number']}\n"
                            f"üí≥ New Balance: ${user_balance:.2f}\n\n"
                            f"‚úÖ Amount refunded to your wallet"
                        ),
                        parse_mode='HTML'
                    )
                except RuntimeError as e:
                    logger.error("Failed to notify user %s: %s",
                                 order['user_id'], str(e))

                await query.edit_message_text(
                    f"‚úÖ <b>Refund Approved & Processed</b>\n\n"
                    f"Order #{order_id} refund completed:\n"
                    f"üí∞ ${order['cost']} refunded to wallet\n"
                    f"üë§ User {order['user_id']} notified\n"
                    f"‚ÑπÔ∏è Provider cancellation not available",
                    parse_mode='HTML'
                )

        elif action == "deny":
            # Update refund status
            db.update_refund_status(order_id, 'denied', user_id)

            # Notify user
            try:
                await context.bot.send_message(
                    chat_id=order['user_id'],
                    text=(
                        f"‚ùå <b>Refund Denied</b>\n\n"
                        f"Your refund request for order #{order_id} has been denied.\n"
                        f"üìû Number: {order['number']}\n\n"
                        f"If you believe this is an error, please contact support."
                    ),
                    parse_mode='HTML'
                )
            except RuntimeError as e:
                logger.error(
                    "Failed to notify user %s: %s", order['user_id'], str(e))

            await query.edit_message_text(
                f"‚ùå <b>Refund Denied</b>\n\n"
                f"Order #{order_id} refund has been denied.\n"
                f"User {order['user_id']} has been notified.",
                parse_mode='HTML'
            )

            logger.info(
                "‚ùå Refund denied by admin %s for order %s", user_id, order_id)

    except RuntimeError as e:
        logger.error("Error processing refund action: %s", str(e))
        await query.edit_message_text("‚ùå Error processing refund action.")

# =============================================================================
# WALLET-BASED PURCHASE HANDLERS (Payment system removed)
# =============================================================================


async def handle_wallet_purchase_confirmation(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle wallet purchase confirmation from user"""
    query = update.callback_query
    user = update.effective_user

    if not query or not user or not query.data:
        return

    await query.answer()

    try:
        # Parse callback data: "wallet_purchase_1574_0.17"
        parts = query.data.split('_')
        if len(parts) < 4:
            await query.edit_message_text("‚ùå Invalid purchase data.", parse_mode='HTML')
            return

        service_id = int(parts[2])
        selling_price = float(parts[3])

        # Get service name from stored user data or default
        service_name = context.user_data.get(
            'selected_service_name', 'Ring4') if context.user_data else 'Ring4'

        # Store selection for processing
        if context.user_data:
            context.user_data['selected_service_id'] = service_id
            context.user_data['selected_service_name'] = service_name
            context.user_data['selected_price'] = selling_price

        # Process the wallet purchase
        await process_wallet_service_purchase(
            user_id=user.id,
            context=context,
            send_method=query.edit_message_text,
            service_id=service_id,
            service_name=service_name
        )

    except ValueError as e:
        await query.edit_message_text(f"‚ùå Invalid purchase data: {str(e)}", parse_mode='HTML')
    except RuntimeError as e:
        logger.error("Error in wallet purchase confirmation: %s", str(e))
        await query.edit_message_text(f"‚ùå Purchase error: {str(e)}", parse_mode='HTML')


# Old payment handlers removed - now using wallet system only
# All service purchases are now instant using wallet balance
# Admin approval only needed for deposits, not individual purchases

async def handle_payment_sent_claim(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle when user claims payment is sent"""
    query = update.callback_query
    if not query or not query.from_user:
        return

    # Extract payment ID from callback data: "payment_sent_PAY_7396254803_1754854768"
    if not query.data:
        await query.answer("‚ùå Invalid request.")
        return

    # Get "PAY_7396254803_1754854768"
    payment_id = "_".join(query.data.split('_')[2:])
    user = query.from_user

    await query.answer()

    # Notify all admins about payment claim
    for admin_id in ADMIN_IDS:
        try:
            keyboard = [[
                InlineKeyboardButton(
                    "‚úÖ Approve", callback_data=f"approve_payment_{payment_id}"),
                InlineKeyboardButton(
                    "‚ùå Deny", callback_data=f"deny_payment_{payment_id}")
            ]]
            reply_markup = InlineKeyboardMarkup(keyboard)

            username = user.username or "Unknown"
            await context.bot.send_message(
                chat_id=admin_id,
                text=(
                    f"üí∞ <b>Payment Claim Received</b>\n\n"
                    f"üë§ <b>User:</b> {user.id} (@{username})\n"
                    f"üí∞ <b>Amount:</b> $5.00 (minimum deposit)\n"
                    f"üÜî <b>Payment ID:</b> <code>{payment_id}</code>\n"
                    f"üè¶ <b>Wallet:</b> <code>{BINANCE_WALLET}</code>\n\n"
                    f"‚ö†Ô∏è <b>Please verify the payment before approving!</b>"
                ),
                parse_mode='HTML',
                reply_markup=reply_markup
            )
        except RuntimeError as e:
            logger.error("Failed to notify admin %s: %s", admin_id, str(e))

    await query.edit_message_text(
        f"‚úÖ <b>Payment Claim Submitted</b>\n\n"
        f"üÜî <b>Payment ID:</b> <code>{payment_id}</code>\n\n"
        f"üë®‚Äçüíº Admins have been notified and will verify your payment.\n"
        f"‚è∞ You'll be notified once the payment is approved.\n\n"
        f"üí° <b>Note:</b> Only send the exact amount to avoid delays.",
        parse_mode='HTML'
    )

    logger.info("üí∞ Payment claim submitted by user %s: %s",
                user.id if user else 'Unknown', payment_id)


async def handle_cancel_payment(update: Update, _context: ContextTypes.DEFAULT_TYPE):
    """Handle payment cancellation"""
    query = update.callback_query
    if not query:
        return

    await query.answer()

    await query.edit_message_text(
        "‚ùå <b>Payment Cancelled</b>\n\n"
        "You can start the purchase process again anytime using /buy or the menu.",
        parse_mode='HTML'
    )

    user_id = query.from_user.id if query.from_user else "Unknown"
    logger.info("üí∞ Payment cancelled by user %s", user_id)


# =============================================================================
# ORDER MANAGEMENT & CANCELLATION HANDLERS
# =============================================================================


async def handle_cancel_order(update: Update, _context: ContextTypes.DEFAULT_TYPE):
    """Handle order cancellation request from user"""
    query = update.callback_query
    if not query or not query.from_user or not query.data:
        return

    user_id = query.from_user.id
    await query.answer()

    try:
        # Extract order_id from callback data: "cancel_order_{order_id}"
        order_id = "_".join(query.data.split('_')[2:])  # Keep as string

        # Verify order exists and belongs to user
        order = db.get_order(order_id)
        if not order:
            await query.edit_message_text(
                "‚ùå <b>Order Not Found</b>\n\n"
                "This order could not be found or may have been already processed.",
                parse_mode='HTML'
            )
            return

        if order['user_id'] != user_id:
            await query.edit_message_text(
                "‚ùå <b>Access Denied</b>\n\n"
                "You can only cancel your own orders.",
                parse_mode='HTML'
            )
            return

        # Check if order can be cancelled (must be pending and no OTP received)
        if order['status'] not in ['pending']:
            status_messages = {
                'completed': 'This order has already been completed with OTP delivery.',
                'cancelled': 'This order has already been cancelled.',
                'timeout': 'This order has already timed out.',
                'refunded': 'This order has already been refunded.',
                'error': 'This order has already been marked as error.'
            }

            message = status_messages.get(
                order['status'], f"This order has status: {order['status']}")

            await query.edit_message_text(
                f"‚ùå <b>Cannot Cancel Order</b>\n\n"
                f"üÜî <b>Order:</b> #{order_id}\n"
                f"üîÑ <b>Status:</b> {order['status']}\n\n"
                f"üìù <b>Reason:</b> {message}\n\n"
                f"üí° If you believe this is an error, contact an administrator.",
                parse_mode='HTML'
            )
            return

        # Show cancellation confirmation
        number = order.get('number', 'N/A')
        cost = order.get('cost', 'N/A')

        await query.edit_message_text(
            f"‚ö†Ô∏è <b>Confirm Order Cancellation</b>\n\n"
            f"üÜî <b>Order ID:</b> #{order_id}\n"
            f"üì± <b>Number:</b> <code>{number}</code>\n"
            f"üí∞ <b>Amount:</b> ${cost}\n\n"
            f"üîÑ <b>What will happen:</b>\n"
            f"‚Ä¢ Your order will be cancelled immediately\n"
            f"‚Ä¢ The number will be released back to the pool\n"
            f"‚Ä¢ Full refund will be processed automatically\n"
            f"‚Ä¢ OTP monitoring will stop\n\n"
            f"‚ùì <b>Are you sure you want to cancel this order?</b>",
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup([
                [
                    InlineKeyboardButton("‚úÖ Yes, Cancel Order",
                                         callback_data=f"confirm_cancel_{order_id}"),
                    InlineKeyboardButton("‚ùå No, Keep Order",
                                         callback_data=f"keep_order_{order_id}")
                ]
            ])
        )

        logger.info(
            "üîî Cancellation confirmation shown for order %s by user %s", order_id, user_id)

    except RuntimeError as e:
        logger.error("‚ùå Error in cancel order handler: %s", str(e))
        await query.edit_message_text(
            "‚ùå <b>Error</b>\n\n"
            "An error occurred while processing your cancellation request.\n"
            "Please try again or contact support.",
            parse_mode='HTML'
        )


async def handle_confirm_cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle confirmed cancellation request"""
    query = update.callback_query
    if not query or not query.from_user or not query.data:
        return

    user_id = query.from_user.id
    await query.answer()

    try:
        # Extract order_id from callback data: "confirm_cancel_{order_id}"
        order_id = "_".join(query.data.split('_')[2:])  # Keep as string

        # Show processing message
        await query.edit_message_text(
            f"üîÑ <b>Cancelling Order...</b>\n\n"
            f"üÜî <b>Order ID:</b> #{order_id}\n\n"
            f"‚è≥ Please wait while we process your cancellation...",
            parse_mode='HTML'
        )

        # Get order details
        order = db.get_order(order_id)
        if not order or order['user_id'] != user_id:
            await query.edit_message_text(
                "‚ùå <b>Error</b>\n\nOrder not found or access denied.",
                parse_mode='HTML'
            )
            return

        # Cancel the polling task if it's active
        if order_id in active_polls:
            active_polls[order_id].cancel()
            del active_polls[order_id]
            logger.info("üõë Cancelled active polling for order %s", order_id)

        # Cancel the order in SMSPool API
        api_cancel_success = False
        api_cancelled_via_api = False
        api_message = "API not available"

        if sms_api:
            try:
                cancel_result = await sms_api.cancel_order(str(order_id))
                api_cancel_success = cancel_result.get('success', False)
                api_cancelled_via_api = cancel_result.get(
                    'api_cancelled', False)
                api_message = cancel_result.get('message', 'Unknown error')

                if api_cancelled_via_api:
                    logger.info(
                        "‚úÖ SMSPool order %s cancelled via API successfully", order_id)
                elif api_cancel_success:
                    logger.info(
                        "‚úÖ Order %s marked for cancellation - user refund guaranteed", order_id)
                else:
                    logger.warning(
                        "‚ö†Ô∏è SMSPool cancel API unavailable for order %s: %s", order_id, api_message)

            except RuntimeError as api_error:
                logger.error(
                    "‚ùå Error cancelling order %s in SMSPool: %s", order_id, str(api_error))
                api_message = f"API error: {str(api_error)}"

        # Update order status to cancelled regardless of API result
        # (user gets refund either way)
        db.update_order_status(order_id, 'cancelled')

        # Create automatic refund record
        db.create_refund_request(user_id, order_id)

        # Notify user about successful cancellation with enhanced messaging
        success_text = "‚úÖ <b>Order Cancelled Successfully</b>\n\n"
        success_text += f"üÜî <b>Order ID:</b> #{order_id}\n"
        success_text += f"üì± <b>Number:</b> <code>{order.get('number', 'N/A')}</code>\n"
        success_text += f"üí∞ <b>Refund Amount:</b> ${order.get('cost', 'N/A')}\n\n"
        success_text += "üîÑ <b>Status Updates:</b>\n"
        success_text += "‚Ä¢ Order marked as cancelled ‚úÖ\n"
        success_text += "‚Ä¢ OTP monitoring stopped ‚úÖ\n"

        if api_cancelled_via_api:
            success_text += "‚Ä¢ Provider order cancelled ‚úÖ\n"
        elif api_cancel_success:
            success_text += "‚Ä¢ Provider cancellation queued ‚è≥\n"
        else:
            success_text += "‚Ä¢ Provider cancellation: Manual review required ‚ö†Ô∏è\n"

        success_text += "‚Ä¢ Refund request created ‚úÖ\n\n"
        success_text += "üí∞ <b>Refund Guarantee:</b>\n"
        success_text += "‚Ä¢ Your refund is <b>guaranteed</b> regardless of provider status\n"
        success_text += "‚Ä¢ Admin will process your refund within 1-24 hours\n"
        success_text += "‚Ä¢ You'll be notified when completed\n\n"

        if not api_cancelled_via_api:
            success_text += "‚ÑπÔ∏è <b>Important:</b> Even if provider cancellation is pending, your full refund is secured.\n\n"

        success_text += "üìû <b>Need help?</b> Contact an administrator."

        await query.edit_message_text(success_text, parse_mode='HTML')

        # Notify all admins about the cancellation
        admin_notification = (
            f"üîî <b>USER ORDER CANCELLATION</b>\n\n"
            f"üë§ <b>User ID:</b> {user_id}\n"
            f"üÜî <b>Order ID:</b> #{order_id}\n"
            f"üì± <b>Number:</b> {order.get('number', 'N/A')}\n"
            f"üí∞ <b>Amount:</b> ${order.get('cost', 'N/A')}\n"
            f"üïê <b>Time:</b> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"
        )

        # Add detailed API cancellation status
        if api_cancelled_via_api:
            admin_notification += "üîÑ <b>Provider Status:</b> ‚úÖ Cancelled via API\n"
        elif api_cancel_success:
            admin_notification += "üîÑ <b>Provider Status:</b> ‚è≥ Cancellation queued\n"
            admin_notification += f"üìù <b>API Response:</b> {api_message[:50]}...\n"
        else:
            admin_notification += "üîÑ <b>Provider Status:</b> ‚ùå Manual review needed\n"
            admin_notification += f"üìù <b>API Issue:</b> {api_message[:50]}...\n"

        admin_notification += (
            "\nüí∞ <b>Action Required:</b> Process refund request\n"
            "‚ÑπÔ∏è <b>Note:</b> User refund guaranteed regardless of provider status"
        )

        for admin_id in ADMIN_IDS:
            try:
                await context.bot.send_message(
                    chat_id=admin_id,
                    text=admin_notification,
                    parse_mode='HTML'
                )
            except RuntimeError as e:
                logger.error("Failed to notify admin %s: %s", admin_id, e)

        logger.info(
            "‚úÖ Order %s cancelled successfully by user %s. API cancelled: %s, Cancel success: %s",
            order_id, user_id, 'Yes' if api_cancelled_via_api else 'No', 'Yes' if api_cancel_success else 'No'
        )

    except RuntimeError as e:
        logger.error("‚ùå Error in confirm cancel handler: %s", str(e))
        await query.edit_message_text(
            f"‚ùå <b>Cancellation Failed</b>\n\n"
            f"An error occurred while cancelling your order:\n"
            f"<code>{str(e)[:100]}...</code>\n\n"
            f"Please try again or contact support.",
            parse_mode='HTML'
        )


async def handle_keep_order(update: Update, _context: ContextTypes.DEFAULT_TYPE):
    """Handle user's decision to keep the order"""
    query = update.callback_query
    if not query or not query.from_user or not query.data:
        return

    user_id = query.from_user.id
    await query.answer()

    try:
        # Extract order_id from callback data: "keep_order_{order_id}"
        order_id = "_".join(query.data.split('_')[2:])  # Keep as string

        order = db.get_order(order_id)
        if not order:
            await query.edit_message_text(
                "‚ùå Order not found.",
                parse_mode='HTML'
            )
            return

        # Restore the original message with cancel button
        service_name = "Ring4"  # Default, could be stored in order data
        selling_price = order.get('cost', 'N/A')
        number = order.get('number', 'N/A')

        success_text = f"üéâ <b>{service_name} Number Ready!</b>\n\n"
        success_text += f"üì± <b>Your Number:</b> <code>{number}</code>\n"
        success_text += f"üí∞ <b>Total Paid:</b> ${selling_price}\n"
        success_text += f"üÜî <b>Order ID:</b> #{order_id}\n"
        success_text += f"üì± <b>Service:</b> {service_name}\n\n"
        success_text += "üîÑ <b>OTP Monitoring:</b> Active (real-time)\n"
        success_text += "‚è±Ô∏è <b>Validity:</b> 10 minutes\n\n"
        success_text += "üöÄ <b>Ready to use!</b> OTP codes will arrive automatically.\n\n"
        success_text += "‚ùå <b>Not working?</b> You can cancel anytime before OTP arrives."

        # Recreate cancel button
        keyboard = [[InlineKeyboardButton(
            "‚ùå Cancel Order & Get Refund",
            callback_data=f"cancel_order_{order_id}"
        )]]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.edit_message_text(
            success_text,
            parse_mode='HTML',
            reply_markup=reply_markup
        )

        logger.info("üì± User %s decided to keep order %s", user_id, order_id)

    except RuntimeError as e:
        logger.error("‚ùå Error in keep order handler: %s", str(e))
        await query.edit_message_text(
            "‚ùå Error occurred. Please try again.",
            parse_mode='HTML'
        )


async def callback_query_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle all callback queries"""
    query = update.callback_query
    if not query or not query.data:
        return

    data = query.data

    try:
        # Wallet-related callbacks
        if data == "deposit_funds":
            await handle_deposit_funds(update, context)
        elif data.startswith("deposit_amount_"):
            await handle_deposit_amount(update, context)
        elif data.startswith("deposit_sent_"):
            await handle_deposit_sent(update, context)
        elif data == "cancel_deposit":
            await handle_cancel_deposit(update, context)
        elif data == "show_balance":
            await balance_command(update, context)
        elif data == "transaction_history":
            await handle_transaction_history(update, context)

        # Service purchase with wallet
        elif data.startswith("wallet_service_"):
            await handle_service_purchase_with_wallet(update, context)
        elif data.startswith("wallet_purchase_"):
            await handle_wallet_purchase_confirmation(update, context)

        # New service selection workflow
        elif data == "browse_services":
            await handle_browse_services(update, context)
        elif data.startswith("select_service_"):
            await handle_service_selection(update, context)
        elif data == "back_to_start" or data == "start":
            await handle_start_menu(update, context)

        # Legacy Ring4 workflow (kept for backward compatibility)
        elif data == "buy_ring4":
            await handle_buy_ring4(update, context)

        # OLD PAYMENT SYSTEM REMOVED - Now using wallet system only
        # All service purchases are instant using wallet balance
        # Admin approval only needed for deposits, not individual purchases

        # Refund workflow callbacks (now using wallet refunds)
        elif data.startswith("refund_") and not data.startswith("refund_details_"):
            await handle_refund_request(update, context)
        elif data == "admin_refunds":
            await show_admin_refunds(update, context)
        elif data.startswith("refund_details_"):
            await handle_refund_details(update, context)
        elif data.startswith("approve_refund_") or data.startswith("deny_refund_"):
            await process_refund_approval(update, context)

        # Order cancellation callbacks
        elif data.startswith("cancel_order_"):
            await handle_cancel_order(update, context)
        elif data.startswith("confirm_cancel_"):
            await handle_confirm_cancel(update, context)
        elif data.startswith("keep_order_"):
            await handle_keep_order(update, context)

        # Admin deposit management
        elif data.startswith("approve_deposit_"):
            await handle_approve_deposit(update, context)
        elif data.startswith("deny_deposit_"):
            await handle_deny_deposit(update, context)

        elif data == "deposit_custom":
            # Handle custom deposit amount
            await handle_deposit_custom(update, context)

        # Unknown callback
        else:
            await query.answer("‚ùå Unknown action.")
            logger.warning("Unknown callback data: %s", data)

    except RuntimeError as e:
        logger.error("Error in callback query handler: %s", str(e))
        try:
            await query.answer("‚ùå An error occurred.")
        except OSError:
            pass


async def handle_text_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle text messages (for custom deposit amounts)"""
    if not update.message or not update.effective_user:
        return

    user = update.effective_user
    message = update.message
    text = message.text

    if not text:
        return

    # Check if user is entering a custom deposit amount
    if context.user_data and context.user_data.get('awaiting_deposit_amount'):
        try:
            # Parse the amount
            amount = float(text.strip())

            # Validate amount
            min_amount = wallet_system.MIN_DEPOSIT_USD if wallet_system else 5.00
            max_amount = wallet_system.MAX_DEPOSIT_USD if wallet_system else 500.00

            if amount < min_amount:
                await message.reply_text(
                    f"‚ùå <b>Amount too low!</b>\n\n"
                    f"Minimum deposit: ${min_amount:.2f}\n"
                    f"Please try again.",
                    parse_mode='HTML'
                )
                return

            if amount > max_amount:
                await message.reply_text(
                    f"‚ùå <b>Amount too high!</b>\n\n"
                    f"Maximum deposit: ${max_amount:.2f}\n"
                    f"Please try again.",
                    parse_mode='HTML'
                )
                return

            # Clear the state
            context.user_data['awaiting_deposit_amount'] = False

            # Create deposit request
            if wallet_system:
                deposit_request = wallet_system.create_deposit_request(
                    user_id=user.id,
                    amount=amount,
                    binance_wallet=BINANCE_WALLET
                )

                # Format deposit instructions
                instructions_text = "üí∞ <b>Wallet Deposit Request</b>\n\n"
                instructions_text += "\n".join(deposit_request['instructions'])

                keyboard = [[
                    InlineKeyboardButton(
                        "‚úÖ Payment Sent", callback_data=f"deposit_sent_{deposit_request['deposit_id']}"),
                    InlineKeyboardButton(
                        "‚ùå Cancel", callback_data="cancel_deposit")
                ]]
                reply_markup = InlineKeyboardMarkup(keyboard)

                await message.reply_text(
                    instructions_text,
                    parse_mode='Markdown',
                    reply_markup=reply_markup
                )

                logger.info(
                    "üí∞ Custom deposit request created for user %s: $%.2f", user.id, amount)
            else:
                await message.reply_text("‚ùå Wallet system not available.")

        except ValueError:
            await message.reply_text(
                "‚ùå <b>Invalid amount format!</b>\n\n"
                "Please enter a valid number (e.g., 10.50)\n"
                "No symbols like $ or USD needed.",
                parse_mode='HTML'
            )
        except RuntimeError as e:
            logger.error("Error handling custom deposit amount: %s", e)
            await message.reply_text(
                "‚ùå Error processing your deposit amount. Please try again."
            )
            context.user_data['awaiting_deposit_amount'] = False

# =============================================================================
# ERROR HANDLING
# =============================================================================


async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Log the error and send a telegram message to notify the developer."""
    logger.error("Exception while handling an update:", exc_info=context.error)

    # Get traceback
    if context.error:
        tb_list = traceback.format_exception(
            None, context.error, context.error.__traceback__)
        logger.error("Error traceback: %s", "".join(tb_list))
    else:
        logger.error("No error traceback available")

    # Notify admins about the error (optional)
    if ADMIN_IDS and update:
        try:
            error_message = str(
                context.error) if context.error else "Unknown error"
            # Only notify first admin to avoid spam
            for admin_id in ADMIN_IDS[:1]:
                await context.bot.send_message(
                    chat_id=admin_id,
                    text=f"‚ö†Ô∏è <b>Bot Error</b>\n\n<code>{error_message[:500]}</code>",
                    parse_mode='HTML'
                )
        except OSError:
            pass

# =============================================================================
# APPLICATION SETUP & MAIN
# =============================================================================


def validate_environment():
    """Validate required environment variables"""
    if not BOT_TOKEN:
        logger.critical("‚ùå BOT_TOKEN not found in environment")
        return False

    if not SMSPOOL_API_KEY:
        logger.critical("‚ùå SMSPOOL_API_KEY not found in environment")
        return False

    if not ADMIN_IDS:
        logger.warning("‚ö†Ô∏è No ADMIN_IDS configured - admin features disabled")

    logger.info("‚úÖ Environment validation passed")
    return True


def main():
    """Main entry point"""
    logger.info("üöÄ Starting Ring4 US-Only SMS Verification Bot")
    logger.info("üêç Python version: %s", sys.version)
    logger.info("üìÅ Working directory: %s", os.getcwd())

    # Print startup banner
    print("""
    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
    ‚ïë                                                              ‚ïë
    ‚ïë              üì± RING4 SMS VERIFICATION BOT                   ‚ïë
    ‚ïë                                                              ‚ïë
    ‚ïë                    Production Ready v1.0                     ‚ïë
    ‚ïë                                                              ‚ïë
    ‚ïë  üéØ Features:                                                ‚ïë
    ‚ïë    ‚Ä¢ Ring4 US numbers only (Service ID: 1574)                ‚ïë
    ‚ïë    ‚Ä¢ Instant purchase & delivery                            ‚ïë
    ‚ïë    ‚Ä¢ Real-time OTP polling (5s interval)                     ‚ïë
    ‚ïë    ‚Ä¢ 10-minute validity period                              ‚ïë
    ‚ïë    ‚Ä¢ Admin-approved refund system                           ‚ïë
    ‚ïë    ‚Ä¢ Persistent TinyDB storage                              ‚ïë
    ‚ïë    ‚Ä¢ Production error handling                               ‚ïë
    ‚ïë                                                              ‚ïë
    ‚ïë  üí∞ Business Ready:                                          ‚ïë
    ‚ïë    ‚Ä¢ SMSPool API integration                                ‚ïë
    ‚ïë    ‚Ä¢ Comprehensive admin controls                           ‚ïë
    ‚ïë    ‚Ä¢ Full audit trails & logging                           ‚ïë
    ‚ïë    ‚Ä¢ Async-first implementation                             ‚ïë
    ‚ïë                                                              ‚ïë
    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    """)

    try:
        # Validate environment
        if not validate_environment():
            sys.exit(1)

        # Create application
        if not BOT_TOKEN:
            logger.critical("‚ùå BOT_TOKEN not configured")
            sys.exit(1)

        application = Application.builder().token(BOT_TOKEN).build()

        # Add command handlers
        application.add_handler(CommandHandler("start", start_command))
        application.add_handler(CommandHandler("buy", buy_command))
        application.add_handler(CommandHandler("help", help_command))
        application.add_handler(CommandHandler("refund", refund_command))
        application.add_handler(CommandHandler("admin", admin_command))
        application.add_handler(CommandHandler(
            "approve_refund", approve_refund_command))
        application.add_handler(CommandHandler("balance", balance_command))
        application.add_handler(CommandHandler(
            "services", service_status_command))

        # Add callback query handler
        application.add_handler(CallbackQueryHandler(callback_query_handler))

        # Add message handler for custom deposit amounts
        application.add_handler(MessageHandler(
            filters.TEXT & ~filters.COMMAND, handle_text_message))

        # Add error handler
        application.add_error_handler(error_handler)

        logger.info("‚úÖ Application setup complete")
        logger.info("ü§ñ Starting bot polling...")

        # Start the bot
        application.run_polling(
            allowed_updates=Update.ALL_TYPES,
            drop_pending_updates=True
        )

    except KeyboardInterrupt:
        logger.info("‚å®Ô∏è Bot stopped by user")
    except RuntimeError as e:
        logger.critical("üí• Fatal error: %s", str(e), exc_info=True)
        sys.exit(1)
    finally:
        # Clean up active polling tasks before event loop closes
        try:
            if active_polls:
                logger.info(
                    "üßπ Cleaning up %s active polling tasks...", len(active_polls))
                for order_id, task in list(active_polls.items()):
                    if not task.cancelled():
                        task.cancel()
                        logger.debug(
                            "‚ùå Cancelled polling task for order %s", order_id)
                active_polls.clear()
                logger.info("‚úÖ All polling tasks cleaned up")
        except RuntimeError as cleanup_error:
            logger.error("‚ö†Ô∏è Error during cleanup: %s", cleanup_error)

        # Close database connections safely
        try:
            if 'db' in globals() and db:
                db.close()
        except RuntimeError as db_error:
            logger.error("‚ö†Ô∏è Error closing database: %s", db_error)

        logger.info("üëã Ring4 Bot shutdown complete")


if __name__ == "__main__":
    main()
